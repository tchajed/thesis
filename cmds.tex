%% semantic formatting
\newcommand{\code}[1]{\texttt{\detokenize{#1}}}
\newcommand{\cc}[1]{\mbox{\smaller[0.5]\texttt{\detokenize{#1}}}}
\newcommand{\scc}[1]{\mbox{\textsc{\detokenize{#1}}}}
\newcommand{\loc}[1]{\num[group-separator={,},group-minimum-digits=4]{#1}}

%% iris.sty extensions for Perennial

% \newcommand{\wpc}[3]{\operatorname{wpc} \, #1 \, \{#2\} \, \{#3\}}
\NewDocumentCommand\wpc{O{} m O{} o m m}%
  {\textlog{\syntax{wpc}}^{#1}_{#3\IfValueT{#4}{,#4}}\spac#2\spac{\syntaxbraced{#5}}\spac{\syntaxbraced{#6}}}

\newcommand{\recoverwith}{\circlearrowleft}
\NewDocumentCommand\wpr{O{} m m O{} m m}%
  {\textlog{\syntax{wpr}}^{#1}_{#4}\spac#2 \recoverwith #3 \spac{\syntaxbraced{#5}}\spac{\syntaxbraced{#6}}}

\newcommand{\wpcw}{\textlog{wpc}}
\newcommand{\wprw}{\textlog{wpr}}
\newcommand{\wpw}{\textlog{wp}}

\newcommand{\notval}[1]{\neg \textlog{value(#1)}}
\newcommand{\cbmask}{\textlog{B}}

\NewDocumentCommand \hoareC {m m m m}{
  \curlybracket{#1}\spac #2 \spac \curlybracket{#3}\curlybracket{#4}%
}

\NewDocumentCommand \hoareCV {O{c} m m m m}{
  {\begin{aligned}[#1]
      &\curlybracket{#2} \\
      &\quad{#3} \\
      &\curlybracket{#4} \\
      &\curlybracket{#5}
    \end{aligned}}%
}
\newcommand{\sep}{*}

\newcommand{\SKIP}{\mathit{noop}}
\renewcommand{\Ret}[1]{\text{\textbf{ret}}\,\, #1,\,}

%%% GoJournal

% temporary commands for compatibility
\newcommand{\txn}{GoJournal\xspace}
\newcommand{\gnfs}{GoNFS\xspace}
\newcommand{\simplenfs}{SimpleNFS\xspace}

% abbreviations
\newcommand{\fstar}{F${}^\star$\xspace}

% GoJournal total
\newcommand{\gotxnLOC}{\loc{1345}}
\newcommand{\gotxnLOP}{\loc{25797}}
% \newcommand{\gotxnRatio}{18}
%
% \newcommand{\gnfsLOC}{\loc{2941}}
%
\newcommand{\simplenfsLOC}{\loc{462}}
\newcommand{\simplenfsLOP}{\loc{3749}}
\newcommand{\simplenfsRatio}{8}
%
\newcommand{\simplenfsCrashLOC}{\loc{44}}

%%% DaisyNFS
\newcommand{\sys}{DaisyNFS\xspace}

% soundness definitions
\newcommand{\refines}{\sqsubseteq}
\newcommand{\progeq}{\approx}

% ``type arg'', to write something like Goose<L>. I'm using angle brackets to
% match C++ and Rust.
\newcommand{\targ}[1]{\langle #1 \rangle}
\newcommand{\layer}{L}
% the type of operations O
\newcommand{\OP}{\mathcal{O}}
\newcommand{\crash}{\operatorname{crash}}
\newcommand{\gooselayer}[1]{\mathtt{Go}\targ{\mathrm{#1}}}
\newcommand{\compile}{C}
\newcommand{\impl}{I}
\newcommand{\init}{\operatorname{init}}

\newcommand{\server}{\texttt{s}}
\newcommand{\sdfy}{\ensuremath{\server_{\mathrm{dfy}}}}
\newcommand{\sdfyAlt}{\ensuremath{\tilde{\server}_{\mathrm{dfy}}}}
\newcommand{\stxn}{\sdfy}
\newcommand{\snfs}{\ensuremath{\server_{\mathrm{NFS}}}}
\newcommand{\txncode}{\texttt{txn}}
\newcommand{\linked}[1]{\ensuremath{\mathrm{link}(#1, \txncode)}}
\newcommand{\linkedcode}{\linked{\sdfy}}
