\section{Verifying DaisyNFS using Dafny}
\label{sec:daisy:proof}

A key contribution of DaisyNFS is a proof structure that isolates concurrency and crash
reasoning to the transaction system. The proof works in two steps. First, a
\emph{simulation transfer} theorem extends GoTxn's program refinement to show
how transactions enable sequential reasoning for an arbitrary system implemented
top (\cref{sec:daisy:simulation-transfer}). Second, the sequential reasoning
is implemented and verified in Dafny for the specific case of DaisyNFS and its
NFS specification (\cref{sec:daisy:proof-dafny}).

\subsection{Simulation transfer}%
\label{sec:daisy:simulation-transfer}

The GoTxn specification from \cref{sec:txn:spec} uses program refinement to
capture that transactions are atomic in the sense that every interleaved
execution has a corresponding execution where each transaction runs all at once.
This section describes a \emph{simulation transfer} theorem, proven in Coq, that
uses program refinement to show how GoTxn enables \emph{sequential
reasoning} for a system implemented with transactions on top.

The idea behind the simulation transfer specification is to express that a system
verified using sequential reasoning for each transaction is also correct when
run concurrently through GoTxn --- intuitively, this follows from the atomicity
provided by program refinement.
% , at which point the sequential reasoning
% applies, but we have a more precise and formal proof in Coq.
To make this precise, we define formally what we mean by
``sequential reasoning''. Suppose we have an
implementation of layer $S$ using operations from $T$. Note that all the proofs
about the transaction system are for an arbitrary system with operations in $S$. The implementation $i$
consists of a function $i(op) : \gooselayer{T}$ for each operation $op \in S$. The statement
$\seqrefinement \targ{T, S}(i)$ says that $i$ is a correct sequential
implementation of $S$ using $T$. To specify correctness under crashes, this
definition refers to $\operatorname{crash}(\sigma, \sigma')$, which is a
layer-specific crash transition that models, for example, clearing the
contents of memory.

\begin{definition}
  The implementation $i : S \to \gooselayer{T}$ is a \emph{sequential
    refinement}, written
  $\seqrefinement \targ{T, S}(i)$, if there exists an abstraction relation
  $R : \Sigma_{S} \to \Sigma_{T} \to \textdom{bool}$ such that: \newline
(1) for every operation
  $op \in S$, the following sequential Hoare triple holds:
  \[
    \hoare{R(\sigma)}{i(op)}{\exists \sigma'.\, R(\sigma') \land \sigma \overset{op}{\leadsto} \sigma'},
  \]
(2) $\mathrm{init}(\sigma_{S}, \sigma_{T})$ implies
$R(\sigma_{S}, \sigma_{T})$, and \\
(3) if $R(\sigma_{T}, \sigma_{S})$ holds and $\operatorname{crash}(\sigma_{T}$, $\sigma_{T}')$,
then there exists a $\sigma_{S}'$ such that $R(\sigma_{T}', \sigma_{S}')$ and
$\operatorname{crash}(\sigma_{S}, \sigma_{S}')$.%
  \label{def:seqrefinement}
\end{definition}
%
Conditions (1) and (2) in this definition are standard for sequential
verification of refinement, while condition (3) is a standard condition for sequential crash-safety~\citep{chajed:argosy}. Though condition (3) requires the
abstraction relation to be preserved by crashes, the proof engineer does \emph{not} have to reason about crashes in the middle of operations.
% is a standard condition for sequential crash-safety~\cite{chajed:argosy}
% for sequential crash safety~\cite{chajed:argosy}.
The
diagram in \cref{fig:refinement} depicts the main
refinement condition (1) diagrammatically.
% For example, it is fairly easy to use them to show
% that for any sequential program $p : \gooselayer{S}$, the traces of the code
% $\mathrm{link}(p, i)$ are a subset of the traces of the spec $p$ (we will not
% use exactly this theorem since we are interested in concurrent code using
% transactions).
% \tej{I mentioned this but maybe we don't want/need to say it?}. Such reasoning would be familiar in previous sequential verified
% systems like FSCQ~\cite{chen:fscq}, IronFleet~\cite{hawblitzel:ironfleet}, and
% VeriBetrKV~\cite{hance:veribetrkv}.

The correctness theorem for GoTxn takes a proof of \emph{sequential} refinement
conditions for a system implemented using transactions and derives a \emph{concurrent and crash-safe} refinement.
A transaction must satisfy some conditions to ensure atomicity. We write
$\mathrm{safe}(p)$ to say that $p$ is a valid transaction. The main
restriction is that $p$ cannot access global state such as the heap, since
the transaction system does not make such accesses atomic; further details are
discussed in \cref{sec:txn:program-refinement}.

The theorem uses
$\atomiccomp i$ to represent a substitution that replaces each operation with
its implementation as a transaction; that is,
$(\atomiccomp i)(op) = \atomically{i(op)}$. $\atomically{i(op)}$ represents an
abstract transaction at the Txn layer, which corresponds to a pattern like the
following when linked with the actual GoTxn implementation (this code snippet
uses Go's support for generics, introduced in version 1.18):

\begin{minted}{go}
type txnBody[T] =
  func(tx *Txn) (v T, ok bool)
func runTxn[T](f txnBody[T]) (v T, ok bool) {
  tx := Begin()
  v, ok := f(tx)
  if ok {
    tx.Commit()
  } else {
    tx.Abort()
  }
  return v, ok
}
\end{minted}

\begin{theorem}[Simulation transfer]
  Let $\textdom{Sys}$ be a layer implemented using transactions with
$i : \textdom{Sys} \to \gooselayer{Txn}$, such that
$\seqrefinement\targ{\gooselayer{Txn}, \textdom{Sys}}(i)$ and
$\forall op.\, \mathrm{safe}(i(op))$ hold. Then
\[
  \forall p : \gooselayer{Sys}, \linked{\mathrm{link}(p, \atomiccomp i)} \refines p.
\]
\label{thm:gotxn-transfer}
\end{theorem}

The theorem assumes only an implementation $i$ which gives the body of each
operation in $\mathit{Sys}$ as a transaction. It then gives a refinement in the
style of program refinement for an arbitrary program $p$ that uses the
$\mathit{Sys}$ API, such as the server loop seen in
\cref{sec:daisy:refinement-spec}. The conclusion is a refinement whose
right-hand side is the program $p$ at the top-most abstraction level of the
system. The left-hand side is the executable code for this program, derived in
two steps: first $\mathrm{link}(p, \atomiccomp i)$ takes each abstract operation
$op$ in $p$ and replaces it with $\atomically{i(op)}$, and second
$\linked{\mathrm{link}(p, \atomiccomp i)}$ takes the result of this process and
further replaces $\atomically{i(op)}$ with executable code that uses the GoTxn
implementation for each call to the Txn API and the \cc{runTxn} pattern above to
make the snippet atomic. The overall refinement says that this executable code
has a subset of behaviors of $p$, so that each operation is not only atomic but
follows the abstract specification of the $\mathit{Sys}$ layer.

\subsection{Using simulation transfer with Dafny}%
\label{sec:daisy:proof-dafny}

\begin{figure}
  %\includegraphics{fig/refinement-execs}
  \begin{center}
  \input{daisy-nfs/fig/refinement-execs.tex}
  \end{center}
  \caption[One execution of DaisyNFS at its three abstraction levels]{One possible execution of DaisyNFS, receiving parallel LOOKUP and
    CREATE operations, at its three abstraction levels.
    Within an execution each row is a thread, and dashed arrows indicate
    context switches.
    The proof shows the bottom execution is equivalent to an atomic execution of
    each thread at
    the Txn layer~(in \cref{thm:gotxn-transfer}),
    and sequential reasoning shows each atomic sequence behaves according to the NFS
    specification~(in \cref{thm:dafny}).}
  \label{fig:refinement-execs}
\end{figure}

In order to use the GoTxn simulation transfer theorem, \cref{thm:gotxn-transfer} to obtain \cref{thm:correctness}, we need to
prove that DaisyNFS's implementation, $i_{NFS}$, satisfies the sequential refinement conditions. To do so, we define
$\seqrefinement_{\mathrm{dfy}}(i)$, an encoding of sequential refinement
using Dafny pre- and post-conditions (as illustrated in \cref{fig:refinement}), and prove that DaisyNFS
satisfies these conditions in Dafny. The crash refinement condition (3) is
straightforward; crashes have no effect in both the Txn layer and the NFS layers
because they do not have ephemeral state.

\begin{theorem} $\seqrefinement_{\mathrm{dfy}}(i_{NFS})$ holds.
  \label{thm:dafny}
\end{theorem}

\begin{figure}
  \centering
  \begin{subfigure}{0.25\textwidth}
    \input{daisy-nfs/fig/create-refinement.tex}
  %  \caption{Diagram view of sequential refinement.}%
  %  \label{fig:refinement:diagram}%
  \end{subfigure}~~~\vrule~~~~%
\begin{subfigure}{0.3\textwidth}
  {\small
\begin{verbatim}

method CREATE(d_ino: uint64,
              name: Bytes)
 returns (r: Result<Ino>)
 requires R(txn_disk, fs)
 ensures R(txn_disk, fs)
 ensures r.Ok? ==>
 nfs3create_spec(d_ino, name,
   old(fs), fs, r.v)
\end{verbatim}
}
  %\caption{Dafny encoding}%
  %\label{fig:refinement:dafny}
\end{subfigure}
  \caption[Illustration of sequential refinement and its Dafny encoding]%
  {Illustration of $\seqrefinement(i_{NFS})$ (left) and its encoding
in Dafny $\seqrefinement_{\mathrm{dfy}}(i_{NFS})$ (right), for one particular operation.
In the diagram, the solid parts are assumed, and the
dashed parts must be shown to exist. The complete Dafny spec is more precise about
errors.}
  \label{fig:refinement}
\end{figure}

From here we can apply \cref{thm:gotxn-transfer} to \cref{thm:dafny} and
obtain \cref{thm:correctness}. \Cref{fig:refinement-execs} illustrates
just one execution that the theorem covers: the transaction system proof guarantees an
atomic execution while the sequential refinement guarantees the transactions
themselves are correct. There are two trusted assumptions needed for the
theorems to compose. First, $\seqrefinement_{\mathrm{dfy}}(i_{NFS})$ should imply
$\seqrefinement(i_{NFS})$. That is, the encoding of the refinement
conditions in Dafny must be correct, but also the semantics of the transaction
system operations modeled in Dafny must match the Coq proof. Second, every Dafny
transaction must be valid, meaning $\mathrm{safe}(i_{NFS}(op))$. The Dafny code
satisfies safety due to a simple syntactic check: the only mutable state in the
file-system Dafny class is the transaction system, so file-system operations
cannot make mutations other than through GoTxn.
% We have some
% confidence this holds due to a simple check over the Dafny code: the only
% mutable state in the Dafny class that implements the file system is the ghost
% variables and the transaction system, so it cannot make mutations other than
% through GoTxn (ghost variables cannot influence execution due to the design of
% Dafny).
