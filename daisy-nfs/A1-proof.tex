\section{Proof of refinement for DaisyNFS}
\label{appendix:proof}

\subsection{Safety}

The more serious restriction is that transactions cannot access the heap at all.
The Dafny code does use the heap, but only ever in a local way to access objects
allocated earlier in the transaction. We can justify this in the proof by
distinguishing $\sdfy$, which is as faithful to the syntactic Dafny code as
possible, from a program $\sdfyAlt$ that is equivalent to $\sdfy$ but where the
use of the heap has been eliminated. $\sdfyAlt$ can be constructed from $\sdfy$
by using a state monad to turn every heap access into purely functional code.
We expect such a construction to succeed because
a simple audit shows that the Dafny code is in a class that has no mutable
variables other than the transaction system and ghost variables,
so it is impossible for a transaction to have a non-local effect.

Applying \cref{thm:txn-appendix} to this revised Dafny program, we obtain that
$\linked{\sdfyAlt} \refines \sdfyAlt$. Given that $\sdfyAlt \progeq \sdfy$, it is
reasonable that the linked versions are also equivalent, completing the first
part of the refinement proof:
\[
  \linked{\sdfy} \progeq \linked{\sdfyAlt} \refines \sdfyAlt \progeq \sdfy
\]

The other side of the refinement comes from reasoning about $\sdfy$ in Dafny.
The theorems proven in Dafny imply that $\sdfy \refines \snfs$. Reasoning about
refinement between these two programs is simple because the granularity of their
concurrency is the same: both have the same structure, but $\sdfy$ executes a
whole implementation for each transaction while $\snfs$ has only one transition.
The Dafny proofs show that $\sdfy$ maintains ghost state corresponding to the
NFS transition system and an invariant that is strong enough to conclude all the
handlers simulate the NFS specification.

\subsection{Initialization and recovery}

The Dafny interface also
uses a constant schema, which DaisyNFS sets to include a super block, some
number of inode blocks, then some allocator blocks, and finally data blocks
for the remainder of the disk.

\subsection{A hypothetical mechanized proof}

One question one might have is why this proof needs to happen on paper. The
agenda for mechanizing it would look something like this: compile the Dafny code
to Go, then abstract away the details of the network interaction to produce
$\server_{\mathrm{code}}$. The same compiled code also gives an explicit
definition of $\sdfy$ where we use Atomically to wrap each transaction. Then, we
might give explicit definitions for each intermediate step, in particular
$\sdfyAlt$ and its compiled version $\linkedcode$. We would prove that
$\sdfyAlt$ is safe; perhaps we could assume dynamic safety of $\sdfy$, trusting
that part to the Dafny proof. We could then show in Coq that
$\server_{\mathrm{code}} \approx \linkedcode \refines \sdfyAlt \equiv \sdfy$,
applying Theorem 1 for the middle step.

There are many barriers to this process. The first is that Goose cannot
translate all of the patterns produced by the Dafny compiler in order to
initially import the Dafny code into Coq. The second is that $\sdfyAlt$ is a
non-trivial transformation of $\sdfy$ to really carry out. Finally, even after
constructing the intermediate programs we would need infrastructure for
reasoning about program equivalences in GooseLang. All of these are surmountable
problems, but it is unlikely that they increase confidence in the proof beyond
careful manual inspection.
