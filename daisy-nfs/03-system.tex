\section{System design}%
\label{sec:daisy:system}

\begin{figure}
  \center
  \input{daisy-nfs/fig/system-overview.tex}
  \caption{The structure of DaisyNFS.}
  \label{fig:system}
\end{figure}

As shown in \cref{fig:system}, DaisyNFS is implemented in three layers:
1) a dispatch loop that speaks the NFS wire protocol and calls the
appropriate method for each operation; 2) a Dafny class that
implements each method; and 3) a transaction system that applies the
updates of each method to the disk atomically.  The dispatch loop is
unverified; we assume that the server correctly decodes messages,
calls the right method for an operation, and encodes the response. The
middle layer implementing the file-system operations is written
and verified in Dafny, which has a backend for Go.  The
third layer is directly written in Go and verified using Coq and
Perennial.  By implementing the file system on top of the transaction
system, we can implement each NFS method in Dafny as sequential code
calling into a concurrent transaction system library. The NFS
operations supported by DaisyNFS are listed in \cref{fig:nfs}.

%% We focus on the
%% design of the transaction system here, but the file system also has several
%% internal abstractions. These abstractions are primarily interesting in a
%% verification context so we discuss them later in \cref{sec:daisy:design}.

%% The file-system implementation calls the transaction system to store all
%% file-system data, ensuring that it is written atomically and durably.
%%
\begin{figure}
  \centering
  \input{daisy-nfs/fig/fslayout.tex}
  \caption{The layout of the file system on top of the transaction system's
    disk. The number of inode blocks and data bitmap blocks are compile-time
    constants, but easy to change without affecting the proofs.}
  \label{fig:layout}
\end{figure}

The file system is responsible for implementing files and directories
onto an array of disk blocks that is exported by the transaction
system.  The disk layout used by the file system is shown in
\cref{fig:layout}, with regions for inode blocks, bitmap blocks,
and data blocks for files and directories. This figure is in terms of
the disk exported by the transaction system; the transaction system
itself reserves a prefix of 513 blocks for the write-ahead log.

The high-level organization of the file system separates three concerns, each
building upon the previous: (1) implementing indirect blocks to support large
files; (2) implementing byte-granularity
reads and writes on top the block-granularity interface below; and (3) implementing
directories by encoding them as files with a special type together with
operations to manipulate those files. \Cref{sec:daisy:design} explains the
internals of the file-system design in more detail, alongside the structure of
the Dafny proof.

%% Each
%% operation takes place in a single transaction at run time, but this transaction
%% is built up by calling methods through several abstraction layers before
%% eventually producing a sequence of transactional reads and writes.

\tej{fix this paragraph}
The proof requires that each 4KB block be accessed with a consistent size. We
represent that in the specification with a fixed ``schema'' specifying the
size of every block address, which is fixed by the caller while calling the
file-system initialization. The schema is never passed to the code and only used
to enforce the consistent-size restriction in the precondition of \cc{Read}
and \cc{Write}. These restrictions are reflected by representing the
transaction system not as an array of bytes but as a mapping from
``addresses'' specifying a block number and offset to ``objects'' which can be
either a boolean or a list of bytes. The schema is a static mapping from block
number to size such that all the objects are of that size.

In practice the file system uses three kinds of objects: full blocks are used
for data (both for directories and data files), bit objects comprise the inode
and block allocators, and 128-byte objects are used to represent inodes. The
file-system statically allocates regions for the inodes, allocator bitmaps,
and data blocks, so that object sizes never change.

Acquiring multiple locks during a transaction creates the possibility
for deadlocks, for example if two threads acquire a pair of locks in the opposite
order. The two-phase locking implementation does not implement a
specific lock acquisition order, leaving it to the file system to
avoid deadlock --- the most interesting case is \cc{RENAME}, which is discussed
in more detail in \cref{sec:dafny:rename}.
