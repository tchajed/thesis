\section{Introduction}

File systems are important to implement correctly because applications rely on
them to safely store user data. Formal verification offers a promise of showing
that an implementation always meets its specification, including a crash safety
property that says the file system recovers correctly from a sudden crash and
reboot. However, efficient implementations are internally complicated,
especially because they support concurrency and aim to minimize disk writes.
This poses a challenge for formal verification: how can a proof cover
concurrency, crash safety, and functional behavior while remaining tractable for
a program the size of a file system?

Crash safety poses a challenge even without verification, so many file systems
use a technique called \emph{journaling} (sometimes called write-ahead logging)
to atomically write multiple objects to disk. An efficient journaling system
goes a long way towards correctness, but it does not protect the programmer from
all concurrency and crash safety reasoning. For example, consider allocating a
block using a combination of an in-memory allocator an on-disk state (to recover
the allocator state on reboot). Suppose one operation is freeing a block from a
file while a concurrent operation is allocating and using it. If the system
crashes, it is possible that the allocation and its writes succeed but the
freeing is aborted, resulting in the same block being part of two files.

The main contribution of this paper is a file-system design that \emph{isolates
crash safety and concurrency reasoning} to a transaction-system
implementation. We take inspiration from databases, which provide SQL
transactions to applications to avoid such tricky concurrency and crash
reasoning when using the database, except in this case the transactions help the
file-system implementation safely access the disk. Unlike existing designs, we
wrap all the file-system data structures and logic inside a transaction. The
benefit of this design is that it is especially verification friendly since it
supports \emph{sequential proofs} for the body of each transaction. Sequential
proofs keep the proof burden manageable even with an efficient implementation
which supports many features, such as large files and in-place updates of
serialized metadata.

There are two challenges in realizing this design. First, how can the entire
file system be implemented using transactions? Ordinarily file systems have some
shared mutable state that is independent of the journal --- the allocator is one
such piece of state that gives rise to the running bug example. We address this
issue by not relying on atomicity of the allocator and instead validating its
results with the journal (experiments demonstrate this has only a small
performance impact). Some operations, like freeing, can require a large number
of disk writes that might not fit in a transaction. We implement freeing using
multiple transactions; a first transaction logically deletes a file, and then
asynchronously the implementation can run transactions that recover space from
the file but have no other visible effect.

The second challenge is how to implement and prove the transaction system
itself. The performance and concurrency of the overall system can only be as
good as the transaction system, so efficiency and fine-grained locking are
important. To that end we start with GoJournal~\cite{chajed:gojournal}, a
verified journaling system that gets good performance and supports concurrent
access to objects smaller than the disk's block size (assumed to be 4KB).
GoJournal leaves concurrency control to the caller, which our transaction system
implements using a standard two-phase locking implementation.

There are two difficulties in proving the transaction system correct using the
GoJournal specificationh. First, this implementation cannot make all
transactions appear sequential; consider a simple example of a transaction that
increments a global variable unknown to the two-phase locking code. Instead, we
formalize a contract specifying rules for which transactions are legal and
assume the caller issues legal transactions in the correctness proof. Second,
most textbook proofs of two-phase locking work by showing that a global conflict
graph between transactions is cycle-free, which implies that the transactions
are serializable. Our proof needs to be tied to the implementation and in
particular the GoJournal specification based on separation logic, so we give a
new proof of two-phase locking's correctness using lock invariants and local
rather than global reasoning.

The verified artifact from this work is \sys, which implements a Network File
System (NFS) server on top of a bare disk and comes with a proof that clients
observe that each operation follows the NFS specification as laid out in RFC
1813. Operations appear atomic despite concurrency and crashes. Clients can use
the Linux or macOS NFS client to mount \sys like any other file system and
interact with it using the usual POSIX API.
As an end-to-end check that our formalization of NFS is
accurate and the implementation is reasonably complete, we tested with both Linux
and macOS clients running a variety of programs and under interactive usage.

A significant benefit of this file-system design is that it permits using the
sharpest tool for each part of the proof: while we use
Perennial~\cite{chajed:gojournal}, a program logic for crash safety and concurrency, for the
transaction system's proof, we use Dafny~\cite{leino:dafny}, a verification-aware
programming language with powerful automation, for the file-system operations.
Dafny is a purely sequential language, but we are able to use it despite this
limitation since the transaction system's proof guarantees transactions behave
sequentially. The value of
sequential proofs can be seen in the proof-to-code ratio for the transaction
system, which is $18\times$, versus the Dafny proofs which required about
$2\times$ as many lines of proof as code. Further evidence can be seen in the
incremental development of DaisyNFS, which we elaborate on in
\autoref{sec:eval:incremental}.

% \joe{Should some of this paragraph's ideas move up to the part where we first argue for the split and describe Dafny as the best tool for the other side?}
% The verification approach we propose makes the proof much simpler. The
% productivity from doing the proofs in Dafny enabled us to rapidly prototype and
% add features incrementally, including triply-indirect blocks, directories, and
% efficient in-memory data structures. These features were important to get good
% performance and support a range of applications. As some quantitative evidence
% for simpler proofs, \sys's \sys's proof is about $2\times$ as many lines as its
% implementation, a rough measure of proof complexity. For comparison, this is
% significantly lower than the overhead in our transaction system (about
% $18\times$) and comparable to the proof:code ratio for the three prior systems
% verified in Dafny, IronClad~\cite{hawblitzel:ironclad} with $4.8\times$,
% IronFleet~\cite{hawblitzel:ironfleet} with $3.6\times$, and VeriBetrKV~\cite{hance:veribetrkv} with
% $4\times$.\footnote{These numbers exclude refinement proofs in these systems
% written on top of the implementation specs, since \sys does not have any
% comparable proofs.}

To evaluate DaisyNFS's performance, we compare it to that of the Linux NFS server
exporting an ext4 file system. \sys achieves almost the same performance as
Linux with the ext4 \cc{data=journal} option (which gives the same crash-safety
guarantees as \sys), across a variety of benchmarks run on top of a fast NVMe
drive. The comparable performance is due to the efficiency of GoJournal and
adding little overhead in the file-system code (e.g., updating data structures
in place to avoid copying). We do note that ext4's default \cc{data=ordered}
mode can get about $2\times$ better throughput for data-heavy workloads, at the
cost of relaxed guarantees on crash.

The contributions of this paper are:
\begin{itemize}
  \item A file-system design that uses transactions in a principled way to
  isolate crash safety and concurrency to the transaction system and use
  sequential proofs for file-system logic.
  \item A contract formalizing which transactions the transaction system can
  make atomic, and a proof of its correctness under this contract.
  \item DaisyNFS, a verified file system and transaction system that implement
  these ideas. A performance evaluation shows that DaisyNFS gets performance
  comparable to Linux ext4 exported over NFS.
\end{itemize}

Our approach and DaisyNFS have some limitations. We do not support NFS unstable
writes, which improve performance by not committing writes to stable storage
until explicitly requested. The proof approach relies on showing that
transactions appear to execute sequentially; this prevents us from modifying state
outside the transaction system (and reasoning about the interaction) where that
would get better performance. The transaction system does not have a proof of
liveness, and we do not prove that transactions avoid deadlock. Our NFS
implementation does not cover the entire API, such as symbolic and hard links,
the ``weak-cache consistency'' metadata to support client-side caching, or
paginated \cc{READDIR}; we believe all of these could be implemented and
specified with the same approach, but have not done so in our prototype.
