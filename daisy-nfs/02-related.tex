\sys is the first verified file system that has both concurrency and crash
safety, but it adopts many ideas from previous verified storage systems,
including some with concurrency. Our main contribution is an approach for
combining verification efforts in different proof systems, which isolates
concurrency reasoning to the transaction system. Prior work has also explored
how to compose proofs across layers for modularity, to contain concurrency, or
to cross between proof systems; we believe \sys advances this work by combining
two software stacks of significant size and complexity.

\subsection{Verifying storage systems}

\paragraph{Directly related systems} \sys directly builds upon
GoJournal~\cite{chajed:gojournal} to implement the transaction system, together
with its new version of the Perennial framework~\cite{chajed:perennial} that is
used to verify the transaction system's proof. This infrastructure is a program
logic designed for storage systems that need a combination of concurrency and
reasoning about crashes at any time, built on top of the Iris
framework~\cite{jung:iris-1} in Coq.

The transaction system differs from GoJournal in that the GoJournal
specification requires the caller to prove that concurrent transactions do not
attempt to read or write the same objects, whereas the transaction system
guarantees this transparently with per-object locks. The specification styles
are also different: whereas the GoJournal proof is a set of specifications
within the Perennial logic, the transaction system's proof uses a more general
refinement-based definition that we can apply to the Dafny code. This is
necessary to combine the tools, since Dafny cannot express the GoJournal
specification's concurrency restrictions directly.

\paragraph{Directly related applications}  The authors of the
Perennial system verified a crash-safe, concurrent mail server under
the assumption that the file system is crash-safe. \sys is a
crash-safe file system and its complexity is significantly larger than
a mail server: the mail server is about 150 lines with a monolithic
proof while \sys combines a transaction system (itself 1,300 lines) with
a 3,000-line file system, each of which involve many intermediate
abstractions.

The authors of GoJournal verify a simple NFS file server on top of
GoJournal, but that server is not complete enough to run real
applications (it supports only one directory and can read/write only
small files).  Furthermore, the simple NFS server does its own locking
and so the proof must reason about concurrency, increasing the proof
overhead compared to \sys.

%% The Dafny side of \sys is a new implementation but its design and aspects of the
%% proof strategy were inspired by other verified file systems like
%% DFSCQ~\cite{chen:dfscq} (especially its indirect block implementation described
%% in Konradi's master's thesis~\cite{akonradi-meng}) and
%% Yggdrasil~\cite{sigurbjarnarson:yggdrasil}.

\paragraph{Other verified file systems}

%% Yggdrasil is implemented with a high degree of automation, with the
%% only lines of proof appearing as intermediate specifications, but the
%% infrastructure uses SMT solving directly and thus doesn't support
%% ordinary program verification like Hoare logic, recursive data
%% structures, and loop invariants, which \sys uses.

%% \mfk{in eval?} For example, in DFSQ, the file-system implementation on
%% top of the journal is about 28,000 lines of combined code and
%% proof. \sys is of comparable complexity in 2,500 lines of imperative
%% Dafny code, which is lower-level than the Gallina language used in
%% DFSCQ\@.

VeriBetrKV~\cite{hance:veribetrkv} is a verified key-value store of
the sort that underpins the BetrFS~\cite{jannen:betrfs} file system. It uses Dafny for
crash-safety reasoning but does not layer any file-system proof on
top. This file-system design does not involve general transactions, so
the code on top of the key-value store must still carry out crash
reasoning.

AtomFS~\cite{zou:atomfs} is a verified concurrent file system that
does not persist data. It uses a custom concurrent relational logic
implemented in Coq.  Because the system does not persist data, AtomFS
does not have any transaction system and implements the top-level
file-system operations together with appropriate locking for
concurrency control.

%\paragraph{GoJournal} \sys's transaction system uses
%GoJournal~\cite{chajed:gojournal}. GoJournal also has a notion of transactions,
%but the caller is required to use locks appropriately to guarantee concurrent
%transactions do not access the same data. Instead of doing this manually, \sys extends GoJournal with
%two-phase locking so that the file system code on top is automatically well-synchronized. Although verifying the two-phase locking requires
%sophisticated reasoning (see~\autoref{sec:txn-proof}), this separation
%allows \sys to use Dafny for sequential reasoning and benefit from
%proof automation.

%% The GoJournal paper presents a
%% separation logic and claims to make reasoning mostly sequential once
%% the caller has established lock invariants. One could ask why we did
%% not directly prove an NFS server with that sequential reasoning. The
%% approach in this paper is better largely because it allows us to use
%% the best tool for that sequential reasoning, rather than using
%% Perennial, which was designed to make proofs of concurrent, crash-safe
%% systems possible without trying to make sequential proofs easy and
%% productive. We think this makes progress towards more accessible
%% verification tools while still reasoning about realistic, concurrent
%% code.

%% Another question relating to GoJournal is why we still needed to verify a
%% transaction system rather than directly relying on its existing results. One
%% simple reason why this was necessary is that GoJournal requires the caller to
%% ensure transactions are non-conflicting, and we needed to prove this somehow. We
%% chose to achieve this in the code with a generic transaction system. One can
%% view the transaction system as a particular use of GoJournal's ``mostly
%% sequential'' specification in order to support not application-specific
%% invariants and transaction but arbitrary ones. Because this is such a general
%% theorem and not the use case envisioned in the GoJournal specification we did
%% have to do some work to prove the transaction system correct, but it largely
%% builds upon rather than replaces the GoJournal specification. If we did not
%% handle the concurrency in a verified transaction system, it would be difficult
%% to set up Dafny to prove this obligation, since once we're using Dafny all code
%% is implicitly sequential. We were concerned that we had no principled way to
%% argue that the overall system is really correct if Dafny was responsible for
%% anything related to concurrency.

\subsection{Concurrency verification}

%% \paragraph{Reducing concurrency to sequential reasoning}
%% \joe{I'm not sure the subsection header works for this one either. Maybe we should kill the subsections? I would not really consider movers a form of composing proofs.}

%% One technique for composing proofs is Lipton's reduction proof technique
%% (sometimes called ``movers'')~\cite{lipton:movers}. The idea is to show that a
%% concurrent system's execution is always equivalent to a rearranged execution where
%% operations execute atomically, reducing the number of interleavings that must be
%% considered in the remainder of the proof.
%% There are many examples of frameworks that use reduction to reason about concurrent and distributed systems, including
%% CIVL~\cite{hawblitzel:civl}, CSPEC~\cite{chajed:cspec}, Armada~\cite{lorch:armada} and
%% IronFleet~\cite{hawblitzel:ironfleet}.

A number of verification frameworks address concurrency, including
CIVL~\cite{hawblitzel:civl}, CSPEC~\cite{chajed:cspec},
Armada~\cite{lorch:armada}, Iris~\cite{jung:iris-jfp}, CCAL~\cite{gu:certikos-ccal},
and FCSL~\cite{sergey:fcsl}, among many others. These frameworks use a range of
methods, such as movers~\cite{lipton:movers} and concurrent separation
logic~\cite{brookes:csl}. Here we focus on those that use techniques closely related to \sys:

% IronFleet~\cite{hawblitzel:ironfleet}.

%% \sys has a similar idea in proving that code running on the transaction system
%% behaves as if the transactions execute atomically. However, instead of using movers,
%% \sys uses Perennial's concurrent separation logic to show that the transaction system's
%% two-phase locking scheme ensures concurrent transactions access disjoint objects, and therefore do not interfere.
%% % However, we do not use the
%% % reduction proof technique directly, instead obtaining this property with a
%% % logical relations proof \tej{what do you cite for logical relations?}.
%% % This proof is able to use Perennial's modularity features to reason about a large
%% %implementation with crash safety and concurrency.
%% Reduction might be hard to scale to such an implementation, and moreover we do not know of any work that
%% extends the movers approach to also address crashes and recovery.


\paragraph{Isolating concurrency}
IronFleet~\cite{hawblitzel:ironfleet} uses Dafny to reason about distributed
system implementations, and VeriBetrKV~\cite{hance:veribetrkv} uses a similar
approach for a sequential storage system. To justify sequential reasoning for
each handler, these approaches use a \emph{reduction} argument, which is
separately formalized in Dafny. The approach in \sys is more general because the
illusion of atomic execution comes from the transaction system implementation,
rather than the nature of distributed execution. Rather than using only a
reduction argument, we use a general-purpose program logic, which is important
for scaling to a large implementation and extending existing techniques with
crash safety reasoning. Even systems which support reduction arguments like
CSPEC~\cite{chajed:cspec}, CIVL~\cite{hawblitzel:civl}, and
Armada~\cite{lorch:armada}, do not rely on only reduction to reason about
programs; we do not know of any work that has extended these systems and all
their proof techniques to incorporate crash safety.

% One difference is that IronFleet's
% protocol reasoning does not involve reasoning about additional code, but only
% the behavior of the lower-level handlers when run together; \sys combines a
% proof about a library with a proof about a code that uses the library.

% \paragraph{Concurrency and crash-safety reasoning} Two frameworks support a
% combination of crash-safety and concurrency: fault-tolerant concurrent
% separation logic (FTCSL)~\cite{ntzik:faults} and
% Perennial~\cite{chajed:perennial,chajed:gojournal}. FTCSL was
% only used to verify a transaction system on paper.  \sys uses
% Perennial to extend GoJournal with two-phase locking, and to verify
% its correctness.

\paragraph{Concurrent library verification}

The specification we prove for the transaction system is a program refinement,
which says something about any code that calls into the transaction system. This
style of specification is powerful for verifying libraries, but it is
challenging since it requires reasoning about any calling program. Some prior
work has verified program refinement (sometimes called contextual refinement in
the literature), notably CertiKOS~\cite{gu:certikos-ccal}, which uses the
approach for several layers in a verified concurrent OS kernel. Program
refinement was also used at a smaller scale in CSPEC~\cite{chajed:cspec} for
concurrent code and in the original Perennial work~\cite{chajed:perennial} for a
concurrent, crash-safe program.


% Another benefit of our approach is that we are not limited to a single
% proof approach: we leverage the custom program logic from Perennial in the
% transaction system's proof and switch to the Dafny sequential program logic for
% the transactions, then compose these proofs despite carrying them out in very
% different systems.

%\tej{moved from soundness section, need to fit into this section}
%
% A solution that leaves the Dafny proofs as simple as possible is to show outside
% of Dafny that the code appears to execute sequentially, justifying the implicit
% assumption in Dafny. IronFleet~\cite{hawblitzel:ironfleet} uses this approach
% with a verified reduction from a distributed (and thus concurrent) execution
% down to a sequential one, which holds as long as the Dafny code follows a
% particular pattern of interactions with the outside world.
% VeriBetrKV~\cite{hance:veribetrkv} takes a similar approach to deal with
% concurrency between a key-value store and a disk.

% In these approaches, the sequential code that is verified in Dafny is a method
% that handles a single request from the network or storage system. In \sys in
% contrast, the atomicity of transactions is due to the correctness of the entire
% transaction system implementation. \tej{haven't figured out how to explain this}

\subsection{Verified two-phase locking}

\citet{ChkliaevHS99} verify serializability of two-phase locking and other
transaction concurrency control mechanisms in the PVS theorem prover. Their
proof formalizes two-phase locking as an abstract protocol consisting of
sequences of read, write, and locking operations, as opposed to a concrete
implementation as in \sys. \citet{pollak-2PL} uses a variant of the
CAP separation logic~\citep{dinsdale:cap} to give a pencil-and-paper
proof of serializability for a two-phase locking implementation.

\citet{mohsen:stm} developed a framework for verifying software transactional memory algorithms, modeled
as I/O automata. They applied their framework to sophisticated STM algorithms, such as
NOrec algorithm~\cite{dalessandro:norec}. The STM algorithms considered do not
handle persistence, so the framework does not address crash-safety reasoning.

% Instead of
% acquiring locks throughout a transaction, the system tracks a \emph{read set} of
% values read.

% To commit, a thread checks if there have been any writes, and if so
% checks if anything in the read set has changed. If the read set is still valid,
% then the commit proceeds (while holding a global lock), and otherwise the
% transaction is forced to abort and start over. This implementation has low
% overhead for low contention workloads, and higher scalability for read-only
% workloads than our two-phase locking design. \tej{probably don't need to say so
% much, just say it's more sophisticated}

\subsection{NFS servers}

We chose to verify an NFS server because it is widely used in practice
and the expected behavior of NFS operations is well documented in
RFCs.  FUSE is an alternative for implementing file systems in user
space, but its operations have a less clear specification.

To be conducive to verification, \sys is implemented differently than
many NFS servers; in particular using two-phase locking is not common
practice.  Other user-level NFS servers are typically implemented on
top of an existing file system, relying on the underlying file system
for logging and locking. The Linux NFS server is implemented inside
the kernel using VFS and the ext3/ext4 file systems (if exporting an
ext3/ext4 file system).  Ext3 and ext4 use a journaling system, but
the file system and VFS layers perform locking.  WAFL~\cite{wafl:hitz}
is NFS appliance that provides snapshots and logs NFS requests to
NVRAM.  It has evolved its locking plan to obtain good
parallelism~\cite{curtis:wafl}.  Both the Linux NFS server and WAFL
are more complicated and have more features than \sys.

% Think Global, Act Local: A Buffer Cache Design for Global Ordering
% and Parallel Processing in the WAFL File System (ICPP)
