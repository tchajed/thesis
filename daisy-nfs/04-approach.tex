\section{Specifying DaisyNFS}%
\label{sec:daisy:spec}

Specifying DaisyNFS takes two steps: first formalizing the NFS protocol, and
then stating how the implementation relates to this formalization.
The specification for NFS is a state machine describing an ideal NFS server in
the form of an abstract state and a transition for each operation. The
implementation of DaisyNFS is a binary \cc{daisy-nfsd} that implements the NFS
protocol, running on top of a
disk. Then the DaisyNFS correctness
theorem is a \emph{refinement} property, which intuitively says that
for any interaction with the
implementation, the ideal, atomic NFS state machine could produce the responses;
this section shortly gives a more formal definition.
As a result a client interacting with the server can pretend
that it is the NFS state machine and ignore the complexities of its
implementation.

\subsection{Formalizing NFS}

RFC 1813 specifies the NFS protocol, which we make mathematically precise with a
state-machine representation defined in Dafny.
The formalization requires first
defining what state operations modify, and then a transition for each
NFS operation that specifies how it changes the state and what return
values are allowed. While most of the specification is deterministic,
some operations have to be specified with non-determinism; for
example, we allow returning an out-of-space error in many operations,
and the specification allows any timestamp to be picked for the
current time. The RFC is precise about arguments and allowed return
values, and the text is good about explaining the intended behavior,
but it does not describe the state an NFS server maintains.  We define
the NFS server state as shown in \cref{fig:dafny-state}.

\begin{figure}[h!]
\begin{small}
\begin{verbatim}
type Ino = uint64
type Path = seq<byte>
datatype Attrs = Attrs(mode: uint32, ...)
datatype File =
  | ByteFile(data: seq<byte>, attrs: Attrs)
  | Dir(dir: map<Path, Ino>, attrs: Attrs)

// the abstract state of the file system
type FilesysData = map<Ino, File>
\end{verbatim}
\end{small}
\caption{Dafny definition of the NFS server state (simplified).}
\label{fig:dafny-state}
\end{figure}

This definition says that an NFS server conceptually maintains a mapping from
inode numbers to files, where a file can either be a regular file with
bytes, or a directory. Both types of files have a number of attributes, storing
metadata like the file's mode (permission bits) and modification time. A
directory is a partial map from file names
(which are just bytes) to inode numbers. Note that DaisyNFS doesn't
represent the file system as a tree but as a collection of
links, which is sufficient to model all NFS operations, because
NFS clients resolve path names.

% \mfk{the rest of this
%   paragraph is lacking a clear narrative.}
% In any case a
% tree wouldn't be a sufficient state for NFS since modifying one file
% affects any other hard links to the same file (note though that DaisyNFS
% does not currently support hard links).

The NFS state machine models each operation as a non-deterministic transition
that answers when it is allowed for an operation to change the state from
\cc{fs} to \cc{fs'} and return \cc{r}. The return value is always wrapped in a
\cc{Result} type, which can be either \cc{Ok(v)} for a normal return or an error
code for one of the errors defined in the standard. The file system systematically guarantees
that the state is unchanged when an operation returns an error (though this is
stronger than what the RFC mandates); the transaction system makes this easy to
achieve by aborting the whole transaction. For example,
\cref{fig:getsz} shows the
specification for a (hypothetical) \cc{GETSZ} operation that returns the size of
the inode \cc{ino}.

\begin{figure}
\small
\begin{verbatim}
predicate GETSZ_spec(ino: Ino, fs: FilesysData,
  fs': FilesysData, r: Result<uint64>)
{
  fs' == fs &&
  (r.ErrBadHandle? ==> ino !in fs) &&
  (r.ErrIsDir? ==> ino in fs && fs[ino].Dir?) &&
  (r.Ok? ==> ino in fs && fs[ino].ByteFile? &&
             r.v == |fs[ino].data|)
}
\end{verbatim}
\caption{Specification of a hypothetical \cc{GETSZ} operation, a simplification
  of the real \cc{GETATTR} operation.}
\label{fig:getsz}
\end{figure}

There are four clauses in the specification. The first just says that this
operation is read-only. The second is one possible error: if the server returns
\cc{ErrBadHandle}, then \cc{ino} is not allocated. The third is a different
error, which says this operation might return \cc{ErrIsDir} for directories.
Finally the fourth clause says that if the operation is successful, it returns the
length of the data in \cc{fs[ino]}. Dafny checks several consistency properties
of this specification itself; for example, a use of \cc{fs[ino]} only compiles
if the specification earlier implies \cc{ino in fs}.

We developed a state-machine model of the regular file and directory operations
in NFS in this style, including specifying what certain errors
signify. \Cref{fig:nfs} lists the entire NFS API and what parts are verified in
DaisyNFS. \tej{this part is a bit out-of-place in this subsection, consider rearranging}

\renewcommand{\check}{\textcolor{ForestGreen}{\checkmark}}
\newcommand{\nope}{\textcolor{Maroon}{\ding{55}}}

\begin{figure}
\small \centering
\begin{tabular}{@{~}ll@{}c@{~}}
  \toprule
  \bf Category & \bf Operations & \bf Verified \\
  \midrule
  \textit{File and directory ops}
  & \cc{GETATTR}, \cc{SETATTR}, \cc{READ}, \cc{WRITE} & \check \\
  & \cc{CREATE}, \cc{REMOVE}, \cc{MKDIR}, \cc{RENAME} & \check \\
  & \cc{LOOKUP}, \cc{READDIR} & \check \\

  \textit{Unsupported features}
  & \cc{READLINK}, \cc{SYMLINK}, \cc{LINK}, \cc{MKNOD} & \nope \\
  & \cc{READDIRPLUS}, \cc{ACCESS} & \nope \\

  \textit{Configuration}
  & \cc{FSINFO}, \cc{PATHCONF}, \cc{FSSTAT} & \nope \\

  \textit{Trivial operations}
  & \cc{NULL}, \cc{COMMIT} & \check \\

  \bottomrule
\end{tabular}
\caption{NFS API and which operations DaisyNFS supports and verifies.}
\label{fig:nfs}
\end{figure}

DaisyNFS implements \cc{FSINFO} and \cc{PATHCONF}, which give the client static
configuration information about the file system (for example, the maximum size
of a write or the maximum path length). These return constants and thus have no
specification. DaisyNFS also implements \cc{FSSTAT} to report total and free space,
but it does not have a meaningful specification.

DaisyNFS could support some of the remaining operations with some more effort.
Symbolic links (symlinks) are essentially a file that holds a path, which can be read with
\cc{READLINK}. \cc{MKNOD} similarly creates a new type of special file.
Specifying these operations would require mostly mechanical changes to the
specification to accommodate the new file types.
\cc{LINK} is more complicated because in addition to tracking
the link count of every file in the state, the specification for \cc{REMOVE}
needs to say that the link count is decremented and that the file is deleted if
its link count drops to zero.

\subsection{Specifying correctness for DaisyNFS}

\begin{figure}[ht]
\small
\centering
\begin{tabular}{@{~}llr@{~}}
\toprule
\bf Layer & \bf Operations & \\
\midrule
  NFS
      & \cc{CREATE(d_ino, name)}, \cc{READDIR(d_ino)}, \dots & \cref{sec:daisy:spec} \\
  Txn
      & \cc{Read(tx, a, sz)}, \cc{Commit(tx)}, \cc{Alloc(a)},
        \dots & \cref{sec:txn:api} \\
  Disk
      & \cc{Read(a)}, \cc{Write(a, b)} & \\
\bottomrule
\end{tabular}
\caption{API layers of DaisyNFS.}
\label{fig:layers}
\end{figure}

The proof is about the server loop at three layers of abstraction, as outlined
in \cref{fig:layers}. The Disk layer at the bottom is where the whole server
runs, while the NFS layer serves as the specification. In addition, there
is an intermediate layer Txn for the transaction system which is the abstraction
on which the Dafny code is written and verified.

Now we have enough to state the final DaisyNFS correctness theorem:
\begin{theorem}[DaisyNFS correctness]
  $\mathrm{link}(\sdfy, \txncode) \refines \snfs$.%
  \label{thm:correctness}
\end{theorem}

%
In this correctness theorem, initialization requires running a Dafny method on
an empty disk. Subsequently the system boots by first recovering the transaction
system, then restoring the file system. \Cref{thm:correctness} will follow
from the correctness of the transaction system combined with the results from
Dafny.
