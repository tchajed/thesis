\section{Crash weakest preconditions}

\newcommand{\propc}{P_c}
\newcommand{\propcB}{Q_c}
\newcommand{\propcC}{R_c}

\newcommand{\wpcseqfig}{%
\begin{mathpar}
\inferH{wpc-value}
{}{\propc \land [\val/\var]\prop \proves \wpc{\val}{\Ret\var \prop}{\propc}}

\inferH{wpc-mono}
{\propc \proves \propcB \and \forall \val.\,\left([\val/\var]\prop \proves [\val/\var]\propB\right)}
{\wpc\expr{\Ret\var \prop}{\propc} \proves \wpc\expr{\Ret\var \propB}{\propcB}}

%\inferH{wpc-bind}
%{\text{$\lctx$ is an evaluation context}}
%{\wpc\expr{\Ret\var  \wpc{\lctx[\var]}{\Ret\varB \propB}{\propcB}}{\propcB} \proves \wpc{\lctx[\expr]}{\Ret\varB \propB}{\propcB}}

\inferH{wpc-frame}
{}{\propB * \wpc\expr{\prop}{\propc} \proves \wpc\expr{\propB*\prop}{\propB*\propc}}

\inferH{wp-wpc}
{}{\wpre\expr{\Ret\var \prop} \dashv\proves \wpc\expr{\Ret\var \prop}{\TRUE}}


\inferH{wpc-atomic}
{\atomic(\expr)}
{\propc \land \wpre\expr{\Ret\var  \propc \land \prop}
 \proves \wpc\expr{\Ret\var \prop}{\propc}}
\end{mathpar}
}

Iris gives tools for proving specifications that capture the concurrency
behavior of a program, but storage systems need stronger specifications that
also cover crash safety. The formal definition of crash safety is ultimately
stated as a property of a storage system combined with a recovery procedure.
Crash safety is \emph{defined} in terms of the results possible after a program
crashes mid-operation, the system reboots, and subsequently a recovery procedure
re-initializes the program.

In Perennial, most of the reasoning required for this recovery-based definition
goes into specifying what happens if the system halts at some intermediate point
and all threads stop running. The core specification idea for reasoning about
this situation is a \emph{crash weakest precondition} $\wpc{e}{Q}{Q_{c}}$. Similar
to the weakest precondition, if $e$ is run from a state satisfying this
predicate and terminates, the resulting state will satisfy $Q$. However, in
addition if the system halts at any time $Q_{c}$ is guaranteed to hold. We also
sometimes write a \emph{crash Hoare quadruple} $\hoareC{P}{e}{Q}{Q_{c}}$ that is
defined to be $P \proves \wpc{e}{Q}{Q_{c}}$. There is one subtlety in the
terminology that while we use the term ``crash'' these postconditions hold
\emph{just prior} to the system actually shutting down, so that the contents of
memory is unchanged.\footnote{They might more properly be called \emph{halt
specifications}, but we used the terminology in the original FSCQ paper and it has
stuck since then. Crash specs are a bit more catchy, anyway.} In \autoref{sec:perennial:recovery} we'll connect these
crash specifications to the memory wipe and reboot that happens right afterward.

\begin{figure}[ht]
  \wpcseqfig
\caption{Basic structural rules for crash weakest preconditions.}%
\label{fig:wpc-seq}
\end{figure}

One rule in Perennial that is often used is the crash frame rule,
\ruleref{wpc-frame}. Like the traditional frame rule, this is a reasoning
principle for ignoring some resources while proving part of a program. When
reasoning about crashes, framing is useful way to dismiss the crash condition
when it refers to durable resources that aren't needed for reasoning about some
part of the code.

The way the rule works is that in analogy to \ruleref{wp-frame}, the premise
is a proof of $Q$ (the frame) and separately $\wpc{e}{P}{P_{c}}$. However, in
addition to framing from the postcondition, Perennial also frames from the crash
condition. A common case is where $P_{c} = \TRUE$, which is useful when $e$ is a
purely in-memory piece of code. In that case we can combine framing
and \ruleref{wp-wpc} to reason about part of a crash Hoare quadruple using
crash-free reasoning, by temporarily ignoring the durable resources $P_d$ in the
precondition:

\[
  \infer{\hoare{P}{e_1}{Q} \and \hoareC{Q \sep P_d}{e_2}{R}{Q_c}}%
  {\hoareC{P \sep P_d}{e_1;\, e_2}{R}{Q_c}}
\]

Another example of combining WPC and WP (crash and crash-free) reasoning is in
the \ruleref{wpc-atomic} rule. The precondition $\atomic(e)$ says this rule only
applies to atomic expressions, which take a single step, and the conclusion is a
WPC for this expression. The premise involves a connective $P \land Q$. This is
a \emph{non-separating conjunction} or ``logical and''. $P \land Q$ holds in
some state when $P$ and $Q$ both hold, but unlike $P \sep Q$ they do not have to
be over disjoint parts of the state, so for example
$p \mapsto v \proves p \mapsto v \land p \mapsto v$ is trivially true. To prove
$\wpc{e}{P}{P_c}$, we need to prove that $P_c$ holds, and using the same pre-execution
resources that $e$ runs to produce $P$ and $P_{c}$ for the same post-execution
resources. The intuitive reason why this rule is sound is that $e$ takes a
single step, so it is sufficient to show the crash condition now (the first
$P_{c}$) and after $e$ executes (the second $P_{c}$). At the same time, the
proof of the crash condition \emph{overlaps with} rather than being disjoint
from the proof of $\wpre{e}{P}$.

To reason about concurrency, Perennial needs some more principles for sharing
ownership between threads. The core mechanism in concurrent separation logic for
reasoning about concurrency is the \emph{invariant}. A thread can allocate an
invariant by giving up $R$ to receive $\knowInv{}{R}$, an assertion that says
$R$ is an invariant --- the precise rule is given in \ruleref{wp-inv-alloc}.
From this point forward, the proof rules guarantee $R$ holds at every program
step. Any thread can ``open'' $\knowInv{}{R}$ with \ruleref{inv-atomic}, which
puts $R$ in the precondition but adds the obligation $R$ to the postcondition.
Invariants can only be opened across an atomic step since other threads might
rely on $R$ during the intermediate steps. Unlike a general resource $R$,
$\knowInv{}{R}$ is duplicable; that is,
$\knowInv{}{R} \proves \knowInv{}{R} \sep \knowInv{}{R}$ --- this is sound
because $\knowInv{}{R}$ is not the underlying resources $R$ but merely knowledge
that $R$ is an invariant.

Invariants have a special role in Perennial. \autoref{fig:wpc-concurrent} lists
some rules for concurrency reasoning. Perennial extends invariant allocation
with a rule \autoref{wpc-inv-alloc}. The non-crash parts of this rule are
identical to \autoref{wp-inv-alloc}, but applying the rule has the additional
benefit of \emph{removing $R$ from the crash condition}. The intuitive reason
this is sound is that since threads maintain $R$ at all intermediate steps, it
must also hold in case the system crashes, and the thread that created the
invariant can get ``credit'' for this on crash.

\begin{figure}
  \begin{mathpar}
    \inferH{wp-inv-alloc}%
    {P \sep \knowInv{}{R} \proves \wpre{e}{Q}}%
    {P \sep R \proves \wpre{e}{Q}}

    \inferH{wpc-inv-alloc}%
    {P \sep \knowInv{}{R} \proves \wpc{e}{Q}{Q_c}}%
    {P \sep R \proves \wpc{e}{Q}{Q_c \sep R}}

    \inferH{wp-fork}%
    {P \proves \wpre{e}{\TRUE} \and Q \proves \wpre{e'}{R}}%
    {P \sep Q \proves \wpre{(\operatorname{fork} \{e\}; \, e')}{R}}

    \inferH{inv-atomic}%
    {\atomic(e) \and R \sep P \proves \wpre{e}{R \sep Q}}%
    {\knowInv{}{R} \sep P \proves \wpre{e}{Q}}
  \end{mathpar}
  \caption{Rules for reasoning about concurrency and ownership transfer with
    invariants.}
  \label{fig:wpc-concurrent}
\end{figure}

Invariants especially useful for lock-free reasoning, but concurrent code
commonly coordinates between threads using locks. \tej{explain the issue with
locks over durable state}

\begin{figure}
  \begin{mathpar}
    \inferH{wp-lock-alloc}%
    {}%
    {P \proves \wpre{\newlock}{\Ret \ell \islock{\ell}{P}}}

    \inferH{wp-lock-use}%
    {P \sep R \proves \wpre{e}{P \sep Q}}%
    {\islock{\ell}{P} \sep R \proves \wpre{(\lock{\ell};\, e;\, \unlock{\ell})}{Q}}

    \inferH{wpc-lock-alloc}%
    {P \proves P_c}%
    {P \proves \wpc{\newlock}{\Ret \ell \iscrashlock{\ell}{P}{P_c}}{P_c}}

    \inferH{wpc-lock-use}%
    {P \sep R \proves \wpc{e}{P \sep Q}{P_c}}%
    {\iscrashlock{\ell}{P}{P_c} \sep R \proves \wpre{(\lock{\ell};\, e;\, \unlock{\ell})}{Q}}

  \end{mathpar}
  \caption{Rules for reasoning about concurrency and crashes with locks.}
\end{figure}

Compared to the regular lock spec (\ruleref{wp-lock-alloc} and
\ruleref{wp-lock-use}), the crash-aware specification (\ruleref{wpc-lock-alloc}
and \ruleref{wpc-lock-use}) associates both a regular lock invariant $P$ with
the lock and a crash condition $P_{c}$. The rule for allocating a lock dismisses
the crash condition, similar to allocating an invariant, and intuitively the
reason why this rule is sound is that when the lock is used with
\ruleref{wpc-lock-use} the caller is obliged to prove $P_{c}$ holds throughout
the entire critical section (whereas the stronger lock invariant $P$ only needs
to be restored at the end).

Crash-aware locks (shouldn't really need crash borrows, only use them as part of
2PL proof because the code doesn't open and close the locks in a bracketed way)

\section{Recovery reasoning}
\label{sec:perennial:recovery}

WPR and idempotence rule

generation numbers to explain how resources transition across a crash
(post-crash modality helps make this concrete in the form of a theorem)

In practice, recovery is the thing that sets up the invariants, cancels from its
crash condition, and then always starts up with the contents of those
invariants due to the recovery idempotence rule.

\section{Soundness}

explain how a soundness theorem relates a WPR to a statement about repeated
execution

mention that a bunch of complexity is hidden in proving that soundness theorem,
some coming from Iris base logic and some from the definition of WPC, but we
won't explain it
