\section{Crash weakest preconditions}

\newcommand{\propc}{P_c}
\newcommand{\propcB}{Q_c}
\newcommand{\propcC}{R_c}

\newcommand{\wpcseqfig}{%
\begin{mathpar}
\inferH{wpc-value}
{}{\propc \land [\val/\var]\prop \proves \wpc{\val}{\Ret\var \prop}{\propc}}

\inferH{wpc-mono}
{\propc \proves \propcB \and \forall \val.\,\left([\val/\var]\prop \proves [\val/\var]\propB\right)}
{\wpc\expr{\Ret\var \prop}{\propc} \proves \wpc\expr{\Ret\var \propB}{\propcB}}

%\inferH{wpc-bind}
%{\text{$\lctx$ is an evaluation context}}
%{\wpc\expr{\Ret\var  \wpc{\lctx[\var]}{\Ret\varB \propB}{\propcB}}{\propcB} \proves \wpc{\lctx[\expr]}{\Ret\varB \propB}{\propcB}}

\inferH{wpc-frame}
{}{\propB * \wpc\expr{\prop}{\propc} \proves \wpc\expr{\propB*\prop}{\propB*\propc}}

\inferH{wp-wpc}
{}{\wpre\expr{\Ret\var \prop} \dashv\proves \wpc\expr{\Ret\var \prop}{\TRUE}}


\inferH{wpc-atomic}
{\atomic(\expr)}
{\propc \land \wpre\expr{\Ret\var  \propc \land \prop}
 \proves \wpc\expr{\Ret\var \prop}{\propc}}
\end{mathpar}
}

Iris gives tools for proving specifications that capture the concurrency
behavior of a program, but storage systems need stronger specifications that
also cover crash safety. The formal definition of crash safety is ultimately
stated as a property of a storage system combined with a recovery procedure.
Crash safety is \emph{defined} in terms of the results possible after a program
crashes mid-operation, the system reboots, and subsequently a recovery procedure
re-initializes the program.

In Perennial, most of the reasoning required for this recovery-based definition
goes into specifying what happens if the system halts at some intermediate point
and all threads stop running. The core specification idea for reasoning about
this situation is a \emph{crash weakest precondition} $\wpc{e}{Q}{Q_{c}}$. Similar
to the weakest precondition, if $e$ is run from a state satisfying this
predicate and terminates, the resulting state will satisfy $Q$. However, in
addition if the system halts at any time $Q_{c}$ is guaranteed to hold. We also
sometimes write a \emph{crash Hoare quadruple} $\hoareC{P}{e}{Q}{Q_{c}}$ that is
defined to be $P \proves \wpc{e}{Q}{Q_{c}}$. There is one subtlety in the
terminology that while we use the term ``crash'' these postconditions hold
\emph{just prior} to the system actually shutting down, so that the contents of
memory is unchanged.\footnote{They might more properly be called \emph{halt
specifications}, but we used the terminology in the original FSCQ paper and it has
stuck since then. Crash specs are a bit more catchy, anyway.} In \autoref{sec:perennial:recovery} we'll connect these
crash specifications to the memory wipe and reboot that happens right afterward.

\begin{figure}[ht]
  \wpcseqfig
\caption{Basic structural rules for crash weakest preconditions.}%
\label{fig:wpc-seq}
\end{figure}

One rule in Perennial that is often used is the crash frame rule,
\ruleref{wpc-frame}. Like the traditional frame rule, this is a reasoning
principle for ignoring some resources while proving part of a program. When
reasoning about crashes, framing is useful way to dismiss the crash condition
when it refers to durable resources that aren't needed for reasoning about some
part of the code.

The way the rule works is that in analogy to \ruleref{wp-frame}, the premise
is a proof of $Q$ (the frame) and separately $\wpc{e}{P}{P_{c}}$. However, in
addition to framing from the postcondition, Perennial also frames from the crash
condition. A common case is where $P_{c} = \TRUE$, which is useful when $e$ is a
purely in-memory piece of code. In that case we can combine framing
and \ruleref{wp-wpc} to reason about part of a crash Hoare quadruple using
crash-free reasoning, by temporarily ignoring the durable resources $P_d$ in the
precondition:

\[
  \infer{\hoare{P}{e_1}{Q} \and \hoareC{Q \sep P_d}{e_2}{R}{Q_c}}%
  {\hoareC{P \sep P_d}{e_1;\, e_2}{R}{Q_c}}
\]

Another example of combining WPC and WP (crash and crash-free) reasoning is in
the \ruleref{wpc-atomic} rule. The precondition $\atomic(e)$ says this rule only
applies to atomic expressions, which take a single step, and the conclusion is a
WPC for this expression. The premise involves a connective $P \land Q$. This is
a \emph{non-separating conjunction} or ``logical and''. $P \land Q$ holds in
some state when $P$ and $Q$ both hold, but unlike $P \sep Q$ they do not have to
be over disjoint parts of the state, so for example
$p \mapsto v \proves p \mapsto v \land p \mapsto v$ is trivially true. To prove
$\wpc{e}{P}{P_c}$, we need to prove that $P_c$ holds, and using the same pre-execution
resources that $e$ runs to produce $P$ and $P_{c}$ for the same post-execution
resources. The intuitive reason why this rule is sound is that $e$ takes a
single step, so it is sufficient to show the crash condition now (the first
$P_{c}$) and after $e$ executes (the second $P_{c}$). At the same time, the
proof of the crash condition \emph{overlaps with} rather than being disjoint
from the proof of $\wpre{e}{P}$.

To reason about concurrency, Perennial needs some more principles for sharing
ownership between threads. The core mechanism in concurrent separation logic for
reasoning about concurrency is the \emph{invariant}. A thread can allocate an
invariant by giving up $R$ to receive $\knowInv{}{R}$, an assertion that says
$R$ is an invariant --- the precise rule is given in \ruleref{wp-inv-alloc}.
From this point forward, the proof rules guarantee $R$ holds at every program
step. Any thread can ``open'' $\knowInv{}{R}$ with \ruleref{inv-atomic}, which
puts $R$ in the precondition but adds the obligation $R$ to the postcondition.
Invariants can only be opened across an atomic step since other threads might
rely on $R$ during the intermediate steps. Unlike a general resource $R$,
$\knowInv{}{R}$ is duplicable; that is,
$\knowInv{}{R} \proves \knowInv{}{R} \sep \knowInv{}{R}$ --- this is sound
because $\knowInv{}{R}$ is not the underlying resources $R$ but merely knowledge
that $R$ is an invariant.

Invariants have a special role in Perennial. \autoref{fig:wpc-concurrent} lists
some rules for concurrency reasoning. Perennial extends invariant allocation
with a rule \autoref{wpc-inv-alloc}. The non-crash parts of this rule are
identical to \autoref{wp-inv-alloc}, but applying the rule has the additional
benefit of \emph{removing $R$ from the crash condition}. The intuitive reason
this is sound is that since threads maintain $R$ at all intermediate steps, it
must also hold in case the system crashes, and the thread that created the
invariant can get ``credit'' for this on crash.

\begin{figure}
  \begin{mathpar}
    \inferH{wp-inv-alloc}%
    {P \sep \knowInv{}{R} \proves \wpre{e}{Q}}%
    {P \sep R \proves \wpre{e}{Q}}

    \inferH{wpc-inv-alloc}%
    {P \sep \knowInv{}{R} \proves \wpc{e}{Q}{Q_c}}%
    {P \sep R \proves \wpc{e}{Q}{Q_c \sep R}}

    \inferH{wp-fork}%
    {P \proves \wpre{e}{\TRUE} \and Q \proves \wpre{e'}{R}}%
    {P \sep Q \proves \wpre{(\operatorname{fork} \{e\}; \, e')}{R}}

    \inferH{inv-atomic}%
    {\atomic(e) \and R \sep P \proves \wpre{e}{R \sep Q}}%
    {\knowInv{}{R} \sep P \proves \wpre{e}{Q}}
  \end{mathpar}
  \caption{Rules for reasoning about concurrency and ownership transfer with
    invariants.}
  \label{fig:wpc-concurrent}
\end{figure}

Invariants especially useful for lock-free reasoning, but concurrent code
commonly coordinates between threads using locks. \tej{explain the issue with
locks over durable state}

\begin{figure}
  \begin{mathpar}
    \inferH{wp-lock-alloc}%
    {}%
    {P \proves \wpre{\newlock}{\Ret \ell \islock{\ell}{P}}}

    \inferH{wp-lock-use}%
    {P \sep R \proves \wpre{e}{P \sep Q}}%
    {\islock{\ell}{P} \sep R \proves \wpre{(\lock{\ell};\, e;\, \unlock{\ell})}{Q}}

    \inferH{wpc-lock-alloc}%
    {P \proves P_c}%
    {P \proves \wpc{\newlock}{\Ret \ell \iscrashlock{\ell}{P}{P_c}}{P_c}}

    \inferH{wpc-lock-use}%
    {P \sep R \proves \wpc{e}{P \sep Q}{P_c}}%
    {\iscrashlock{\ell}{P}{P_c} \sep R \proves \wpre{(\lock{\ell};\, e;\, \unlock{\ell})}{Q}}

  \end{mathpar}
  \caption{Rules for reasoning about concurrency and crashes with locks.}
\end{figure}

Compared to the regular lock spec (\ruleref{wp-lock-alloc} and
\ruleref{wp-lock-use}), the crash-aware specification (\ruleref{wpc-lock-alloc}
and \ruleref{wpc-lock-use}) associates both a regular lock invariant $P$ with
the lock and a crash condition $P_{c}$. The rule for allocating a lock dismisses
the crash condition, similar to allocating an invariant, and intuitively the
reason why this rule is sound is that when the lock is used with
\ruleref{wpc-lock-use} the caller is obliged to prove $P_{c}$ holds throughout
the entire critical section (whereas the stronger lock invariant $P$ only needs
to be restored at the end).

\section{Recovery reasoning}
\label{sec:perennial:recovery}

A practical storage system handles crashes by restoring its in-memory state of
the system. We call the procedure that runs after a crash on every reboot the
system's \emph{recovery procedure}. To reason about the recovery process, we
introduce a \emph{recovery} weakest precondition $\wpr{e}{e_{r}}{P}{P_{r}}$,
where $e$ represents the storage system, $e_{r}$ is a recovery procedure that
will run on restart, $P$ is the postcondition for normal execution, and $P_{r}$
is the \emph{recovery postcondition}. When $e$ is run in a state satisfying this
$\wprw$, if it terminates normally then $P$ holds, and if the system crashes and
$e_{r}$ terminates then $P_{r}$ holds. The latter is true even if the system
crashes while running $e_{r}$ and restarts all over again.

Perennial has only one rule to prove a $\wprw$, which reduces it to proving a
$\wpcw$ about $e$ and an \emph{idempotent} specification for
$e_{r}$~\cite{chen:fscq}:

\[
  \inferH{wpr-idempotence}%
{\operatorname{durable}(P_{c}) \and P_{c} \proves \wpc{e_{r}}{P_{r}}{P_{c}}}%
{\wpc{e}{P}{P_{c}} \proves \wpr{e}{e_{r}}{P}{P_{r}}}
\]

At a high level, the user proves $\wpr{e}{e_{r}}{P}{P_{r}}$ in two steps:
\begin{enumerate}
  \item First, prove $\wpc{e}{P}{P_c}$ to cover normal terminal and establish a
  global crash invariant $P_{c}$ for the program.
  \item Second, prove $P_{c} \proves \wpc{e_{r}}{P_{r}}{P_{c}}$ to establish the
  recovery postcondition from the crash condition and show that recovery
  maintains the crash invariant so that crashes during recovery are also
  handled.
  \item Finally, prove $\durable(P_{c})$, which asserts that the
  crash invariant is stated using only \emph{durable} resources that survive a
  crash.
\end{enumerate}

The final step, the durability side condition, is where the proof takes into
account the effect of a crash. For example $\wpc{e}{P}{P_{c}}$ proves that
$P_{c}$ holds just prior to a crash while
$P_{c} \proves \wpc{e_{r}}{P_{r}}{P_{c}}$ starts reasoning just after the crash.
Durability is defined so that if $P_{c}$ is durable, it holds across a crash.

The effect of a crash is to wipe memory. Encoding this in separation logic is a
bit tricky, since it would appear that assertions about in-memory pointers like
$p \mapsto v$ need to be invalidated. The logic handles this by instead
parameterizing all heap assertions and weakest preconditions with a
\emph{generation number}. Across a crash, the generation number is incremented,
so that old assertions are true but no longer work for loads and stores since
they do not apply to the current heap. Then $\durable(P)$ is defined to say that
the assertion $P$ is independent of the current generation number.

In practice the way the $\wprw$ assertion is used is by applying it to an $e$
that is a server loop that accepts operations, executes them, and replies. The
same loop $e$ is also $e_{r}$ since it restores its state from disk. Finally, we
separately prove that $e$ is safe to run from an initial state with an all-zero
disk.

In practice, the recovery code sets up the global invariants and appropriate
crash locks for the whole system and thus cancels all of these assertions from
its crash condition, contributing to the proof of $P_{c}$. Then the proof rules
in Perennial guarantee that recovery can assume $P_{c}$ holds if the system
crashes and reboots at any time, as given by the idempotence rule.

\section{Soundness}

explain how a soundness theorem relates a WPR to a statement about repeated
execution

mention that a bunch of complexity is hidden in proving that soundness theorem,
some coming from Iris base logic and some from the definition of WPC, but we
won't explain it
