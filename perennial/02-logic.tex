\section{Crash weakest preconditions}

\newcommand{\propc}{P_c}
\newcommand{\propcB}{Q_c}
\newcommand{\propcC}{R_c}

\newcommand{\wpcseqfig}{%
\begin{mathpar}
\inferH{wpc-value}
{}{\propc \land [\val/\var]\prop \proves \wpc{\val}{\Ret\var \prop}{\propc}}

\inferH{wpc-mono}
{\propc \proves \propcB \and \forall \val.\,\left([\val/\var]\prop \proves [\val/\var]\propB\right)}
{\wpc\expr{\Ret\var \prop}{\propc} \proves \wpc\expr{\Ret\var \propB}{\propcB}}

%\inferH{wpc-bind}
%{\text{$\lctx$ is an evaluation context}}
%{\wpc\expr{\Ret\var  \wpc{\lctx[\var]}{\Ret\varB \propB}{\propcB}}{\propcB} \proves \wpc{\lctx[\expr]}{\Ret\varB \propB}{\propcB}}

\inferH{wpc-frame}
{}{\propB * \wpc\expr{\prop}{\propc} \proves \wpc\expr{\propB*\prop}{\propB*\propc}}

\inferH{wp-wpc}
{}{\wpre\expr{\Ret\var \prop} \dashv\proves \wpc\expr{\Ret\var \prop}{\TRUE}}


\inferH{wpc-atomic}
{\atomic(\expr)}
{\propc \land \wpre\expr{\Ret\var  \propc \land \prop}
 \proves \wpc\expr{\Ret\var \prop}{\propc}}
\end{mathpar}
}

Iris gives tools for proving specifications that capture the concurrency
behavior of a program, but storage systems need stronger specifications that
also cover crash safety. The formal definition of crash safety is ultimately
stated as a property of a storage system combined with a recovery procedure.
Crash safety is \emph{defined} in terms of the results possible after a program
crashes mid-operation, the system reboots, and subsequently a recovery procedure
re-initializes the program.

In Perennial, most of the reasoning required for this recovery-based definition
goes into specifying what happens if the system halts at some intermediate point
and all threads stop running. The core specification idea for reasoning about
this situation is a \emph{crash weakest precondition} $\wpc{e}{Q}{Q_{c}}$. Similar
to the weakest precondition, if $e$ is run from a state satisfying this
predicate and terminates, the resulting state will satisfy $Q$. However, in
addition if the system halts at any time $Q_{c}$ is guaranteed to hold. We also
sometimes write a \emph{crash Hoare quadruple} $\hoareC{P}{e}{Q}{Q_{c}}$ that is
defined to be $P \proves \wpc{e}{Q}{Q_{c}}$. There is one subtlety in the
terminology that while we use the term ``crash'' these postconditions hold
\emph{just prior} to the system actually shutting down, so that the contents of
memory is unchanged.\footnote{They might more properly be called \emph{halt
specifications}, but we used the terminology in the original FSCQ paper and it has
stuck since then. Crash specs are a bit more catchy, anyway.} In \autoref{sec:perennial:recovery} we'll connect these
crash specifications to the memory wipe and reboot that happens right afterward.

\begin{figure}[ht]
  \wpcseqfig
\caption{Basic structural rules for crash weakest preconditions.}%
\label{fig:wpc-seq}
\end{figure}

One rule in Perennial that is often used is the crash frame rule,
\ruleref{wpc-frame}. Like the traditional frame rule, this is a reasoning
principle for ignoring some resources while proving part of a program. When
reasoning about crashes, framing is useful way to dismiss the crash condition
when it refers to durable resources that aren't needed for reasoning about some
part of the code.

The way the rule works is that in analogy to \ruleref{wp-frame}, the premise
is a proof of $Q$ (the frame) and separately $\wpc{e}{P}{P_{c}}$. However, in
addition to framing from the postcondition, Perennial also frames from the crash
condition. A common case is where $P_{c} = \TRUE$, which is useful when $e$ is a
purely in-memory piece of code. In that case we can combine framing
and \ruleref{wp-wpc} to reason about part of a crash Hoare quadruple using
crash-free reasoning, by temporarily ignoring the durable resources $P_d$ in the
precondition:

\[
  \infer{\hoare{P}{e_1}{Q} \and \hoareC{Q \sep P_d}{e_2}{R}{Q_c}}%
  {\hoareC{P \sep P_d}{e_1\, e_2}{R}{Q_c}}
\]

Another example of combining WPC and WP (crash and crash-free) reasoning is in
the \ruleref{wpc-atomic} rule. The precondition $\atomic(e)$ says this rule only
applies to atomic expressions, which take a single step, and the conclusion is a
WPC for this expression. The premise involves a connective $P \land Q$. This is
a \emph{non-separating conjunction} or ``logical and''. $P \land Q$ holds in
some state when $P$ and $Q$ both hold, but unlike $P \sep Q$ they do not have to
be over disjoint parts of the state, so for example
$p \mapsto v \proves p \mapsto v \land p \mapsto v$ is trivially true. To prove
$\wpc{e}{P}{P_c}$, we need to prove that $P_c$ holds, and using the same pre-execution
resources that $e$ runs to produce $P$ and $P_{c}$ for the same post-execution
resources. The intuitive reason why this rule is sound is that $e$ takes a
single step, so it is sufficient to show the crash condition now (the first
$P_{c}$) and after $e$ executes (the second $P_{c}$). At the same time, the
proof of the crash condition \emph{overlaps with} rather than being disjoint
from the proof of $\wpre{e}{P}$.

Most important rule: allocating an invariant cancels from the crash invariant
(encoding Perennial 1.0 reasoning)

Crash-aware locks (shouldn't really need crash borrows, only use them as part of
2PL proof because the code doesn't open and close the locks in a bracketed way)

\section{Recovery reasoning}
\label{sec:perennial:recovery}

WPR and idempotence rule

generation numbers to explain how resources transition across a crash
(post-crash modality helps make this concrete in the form of a theorem)

In practice, recovery is the thing that sets up the invariants, cancels from its
crash condition, and then always starts up with the contents of those
invariants due to the recovery idempotence rule.

\section{Soundness}

explain how a soundness theorem relates a WPR to a statement about repeated
execution

mention that a bunch of complexity is hidden in proving that soundness theorem,
some coming from Iris base logic and some from the definition of WPC, but we
won't explain it
