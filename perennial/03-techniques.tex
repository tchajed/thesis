\section{Reasoning techniques in Perennial}
\label{sec:perennial:techniques}

On top of the Perennial logic, we developed some techniques to organize proofs
of libraries and compose them. Of particular interest is a pattern for
\emph{logically-atomic crash specifications}, which capture that a set of
methods in a library appear atomic with respect to both other threads and on
crash. In order to illustrate how all of these techniques work together, this
section walks through the specification and proof intuition for the circular
buffer, a library used in GoTxn that has interesting crash safety and
concurrency behavior. This library operates directly on top of the disk, so no
background on GoTxn is needed to understand it.

The circular buffer (``circ'' for short) is essentially an on-disk queue of
updates, which are pairs of an address and a disk block. It is used to implement
write-ahead logging: disk writes are first stored in the circular buffer, and
then eventually moved to a separate data region. It supports two operations
during normal usage: \cc{Append(upds)} appends a list of updates to the buffer
and \cc{TrimTill(pos)} deletes updates up to \cc{pos}. Queue positions grow
indefinitely, but the buffer can hold at most 511 updates at a time and it
is the caller's responsibility to avoid overflowing with \cc{Append}. The only
read operation is recovery, which restores the durable updates and current queue
position; in practice the contents are cached, but this is the caller's concern.

There are three challenges in giving the circ library a specification. First, we
want to show that \cc{Append} appears to be atomic to the caller, even though it
internally writes many disk blocks. Second, the library has some thread-safety
requirements to enforce on the caller: in particular \cc{Append} and
\cc{TrimTill} can be called concurrently from separate threads, but it is not
safe to overlap multiple appends or multiple trim requests. Finally, the library
relies on the caller to guarantee that append and trim are called with enough
available space. These last two challenges are due to leaving concurrency
control to the caller, which is more efficient than the circular buffer having
its own redundant locking.

The basic idea is that the circular buffer is specified in terms of an abstract
state that evolves through an atomic transition for each operation. Recovery can
recover the pre-crash state of the buffer. The state for this library consists
of two components: a list of updates (which are pairs of an address to write to
and a 4KB block to write there) and a 64-bit start position that indicates how
many updates occurred prior to the current list of updates. Append, as
mentioned, simply appends to the list of updates. The argument to \cc{TrimTill}
is a position of this form; the effect of \cc{TrimTill(pos)} is to delete
\cc{pos - start} updates from the beginning of the list of updates and set the
new start position to \cc{pos}.

Formally the way each operation is specified is using a style called
HOCAP~\cite{svendsen:hocap,jacobs:modular-lin}. The basic idea is that the
library maintains an invariant $P(\sigma)$, where $\sigma$ is the current
abstract state; a key idea in the HOCAP specification is that this predicate $P$
is chosen by the client. For each operation, the client passes in a
\emph{view-shift assertion} written $P(\sigma) \vs P(\sigma') * Q$, where the
transition from $\sigma$ to $\sigma'$ is a valid transition for the operation.
This view shift represents a kind of once-usable ``callback'' which transforms
$P(\sigma)$ into $P(\sigma')$, typically by updating the caller's ghost state in
$P$. At the end of the operation, the client receives $Q$ as a kind of
certificate that the callback ran. The intuition for why this specification
style captures linearizability is that the library does not know anything about
$P$ or $Q$ and thus the only way to preserve $P$ and produce $Q$ at the end is
to call the callback at exactly the linearization point of the operation.

In this section, we describe how we extend the HOCAP idea to recovery. The focus
is on the specification style used, without going into how the proofs are
carried out. All these specifications are given in the context of the
circular-buffer library, used as part of the write-ahead log. This library has
some interesting concurrency complications that are also solved in its
specification, so we will highlight what aspects are specific to the circular
buffer's concerns and which are part of the general crash HOCAP pattern.

The circular buffer is used as part of the write-ahead log. It stores a queue of
updates (address-block pairs) on disk, and supports appending multiple updates
in a way that is atomic on crash. The calling code (the write-ahead log code)
doesn't read from the circular buffer during normal execution, only during
recovery; the entries in the queue are cached and must be restored to preserve
atomicity and durability.

The circular buffer the following API: \tej{format this API properly}

\begin{itemize}
  \item \cc{func InitCircular() *circAppender}
  \item \cc{func (c *circAppender) Append(end uint64, upds []Update)}
  \item \cc{func TrimTill(start uint64)}
  \item
\begin{verbatim}
func RecoverCircular()
       (c *circAppender,
        start uint64, end uint64, upds []Update)
\end{verbatim}
\end{itemize}

The abstract state of the circular buffer is a queue of updates together with a
``start position'' that tracks how many historical updates have been appended.
We will write $\sigma$ for the abstract state of the circular buffer; the type
of this state is a record with a field for the updates of type \cc{list(uint64 *
Block)} and a field for the start of type \cc{uint64}. This start position is
used to interpret the argument to \cc{TrimTill}, which deletes based on an
absolute position. The \cc{Append} operation takes the current \cc{end} position
of the log because the circular buffer does not internally track the end
position (the caller needs to track the position anyway).

\tej{oops, this was explained above in this section}
A key feature of the circular buffer is that \cc{Append} and \cc{TrimTill} can
be called concurrently --- the former is called by the logger thread to make
writes durable while the latter is called by the installer thread to make space
for new writes (after installing the old ones to the rest of the disk). The
circular buffer takes only fixed size on disk, and the calling code is
responsible for ensuring that \cc{Append} calls never overflow this fixed size
since this would wrap around and corrupt old data. Similarly, the caller is
responsible for calling \cc{TrimTill} with a \cc{start} that fits within the
circular buffer.

The specifications use the following separation logic resources issued by the
circular buffer:

\newidentmacro{length}

\begin{itemize}
  \item $\cc{circular_state}(\gamma, \sigma)$, which says that the current state
  of the circular buffer is $\sigma$. The $\gamma$ argument is a ``ghost name''
  for the ghost state associated with this instance of the circular buffer; at
  any time there is only one circular buffer, but this name will change every
  time the system crashes and reboots and thus distinguishes different
  ``generations'' of the circular buffer.
  \item $\cc{is_circular}(\gamma)$, defined to be
  $\knowInv{}{\exists \sigma, \cc{circular_state}(\gamma, \sigma) * P(\sigma)}$.
  \item $\cc{circ_appender}(\gamma, \ell)$. This relates the circular buffer's
  ghost state with $\ell$, a \cc{*circularAppender} pointer that has some data
  needed to append to the circular buffer. This resource is not persistent and
  is owned by the logger thread.
  \item $\cc{start_is}(\gamma, \cc{start})$ and
  $\cc{end_is}(\gamma, \cc{end})$ give the exact current positions of the start
  and end (that is, $\sigma.\cc{start} + \length(\sigma.\cc{updates})$) of
  the circular buffer. These resources are not persistent and owned retained by
  the installer and logger threads respectively.
  \item $\cc{start_at_least}(\gamma, \cc{start})$ and
  $\cc{end_at_least}(\gamma, \cc{end})$ give \emph{lower bounds} on the start
  and end positions. These resources are persistent. It is possible to issue
  such resources because the start and end monotonically increase, which is also
  why they are persistent; once \cc{start} reaches some value that is always a
  valid lower bound.
\end{itemize}

The specifications for the core \cc{Append} and \cc{TrimTill} operations refer
to the start and end ghost variables through the corresponding resources. Let us
first look at Append:

\begin{align*}
  &\{ \cc{is_circular}(\gamma) \sep {} \\
&\quad (\forall \sigma, P(\sigma) \vs P(\sigma + \cc{upds}) * Q) \\
&\quad \cc{circ_appender}(\gamma, \cc{c}) \sep {} \\
&\quad \cc{end_is}(\cc{end}) \sep \cc{start_at_least}(\cc{start}) \sep (\cc{end} - \cc{start} + \length(\cc{upds}) < 511) \sep {} \\
&\} \\
&\qquad\cc{c.Append(end, upds)} \\
&\{ \cc{end_is}(\cc{end} + \length(\cc{upds})) \sep Q \} \\
\end{align*}

There are several aspects to the specification, mostly in the precondition. The
first line is the most straightforward: we need the circular buffer's invariant
to hold, for a particular ghost name $\gamma$. The second line is part of the
general HOCAP pattern. As described above, this is a view-shift assertion
provided by the caller that updates the user-defined invariant $P(\sigma)$ in
accordance with the \cc{Append} operation. We've written $\sigma + \cc{upds}$ as
a shorthand, but the new state is really $\sigma$ with \cc{upds} appended to the
updates field (and the same \cc{start}). Again, the idea is that this view shift
is executed at the linearization point of the \cc{Append} operation, changing
the state inside the $\cc{is_circular}$ invariant. The view shift produces a
user-supplied assertion $Q$ which is returned in the postcondition. Intuitively
this assertion is what captures that the Append proof really executed the view
shift. \tej{quite redundant with above, maybe just move that explanation down here}

The rest of the specification is specific to how the circular buffer manages
concurrency.

\tej{things to figure out from the circular buffer/WAL proofs:}
\begin{enumerate}
  \item how does a lower bound before a crash get turned into knowledge after
  the crash?
  \item why does \cc{crash_obligation_alt} have both a cfupd and an invariant in
  the postcondition?
\end{enumerate}

\resume
