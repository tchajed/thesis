\section{Specifying crash-safe libraries in Perennial}
\label{sec:perennial:techniques}

On top of the Perennial logic, we developed a specification pattern to organize proofs
of libraries and compose them. Of particular interest is a pattern for
\emph{logically-atomic crash specifications}, which capture that a set of
methods in a library appear atomic with respect to both other threads and on
crash. In order to illustrate how all of these techniques work together, this
section walks through the specification and proof intuition for the circular
buffer, a library used in GoTxn that has interesting crash safety and
concurrency behavior. This library operates directly on top of the disk, so no
background on GoTxn is needed to understand it.

\subsection{The circular buffer library}

The circular buffer (``circ'' for short) is essentially an on-disk queue of
updates, which are pairs of an address and a disk block. It is used to implement
write-ahead logging: disk writes are first stored in the circular buffer, and
then eventually moved to a separate data region. It supports two operations
during normal usage: \cc{Append(upds)} appends a list of updates to the buffer
and \cc{TrimTill(pos)} deletes updates up to \cc{pos}. Queue positions grow
indefinitely, but the buffer can hold at most 511 updates at a time and it
is the caller's responsibility to avoid overflowing with \cc{Append}. The only
read operation is recovery, which restores the durable updates and current queue
position; in practice the contents are cached, but this is the caller's concern.

There are three challenges in giving the circ library a specification. First, we
want to show that \cc{Append} appears to be atomic to the caller, even though it
internally writes many disk blocks. Second, the library has some thread-safety
requirements to enforce on the caller: in particular \cc{Append} and
\cc{TrimTill} can be called concurrently from separate threads, but it is not
safe to overlap multiple appends or multiple trim requests. Finally, the library
relies on the caller to guarantee that append and trim are called with enough
available space. These last two challenges are due to leaving concurrency
control to the caller, which is more efficient than the circular buffer having
its own redundant locking.

The basic idea is that the circular buffer is specified in terms of an abstract
state that evolves through an atomic transition for each operation. Recovery can
recover the pre-crash state of the buffer. The state for this library consists
of two components: a list of updates (which are pairs of an address to write to
and a 4KB block to write there) and a 64-bit start position that indicates how
many updates occurred prior to the current list of updates. Append, as
mentioned, simply appends to the list of updates. The argument to \cc{TrimTill}
is a position of this form; the effect of \cc{TrimTill(pos)} is to delete
\cc{pos - start} updates from the beginning of the list of updates and set the
new start position to \cc{pos}.

The circular buffer has the following API:

\begin{minted}{go}
func InitCircular() *circAppender
func (c *circAppender) Append(end uint64, upds []Update)
func TrimTill(start uint64)
func RecoverCircular() (c *circAppender,
        start uint64, upds []Update)
\end{minted}

The write-ahead log uses the circular buffer from two threads, one dedicated to
\emph{logging} which appends to the circular buffer to make writes durable and another
dedicated to \emph{installation} which trims writes from the circular buffer
after installing them. Appending and trimming can be performed concurrently, but
appending requires the \cc{*circAppender} struct which is not thread-safe. The
caller only reads from the circular buffer if the system crashes, at which point
recovery restores the previous state. During normal operation the caller keeps a
separate in-memory cache of the entries in the circular buffer.

\subsection{Circular buffer custom resources}

Perennial, like Iris, has support for user-defined separation-logic resources.
These are defined using lower-level mechanisms, but here we simply present the
resources and the intuition for how they are used without going into details on
how they are implemented. The circular buffer defines and issues the
following custom separation-logic resources:

\newidentmacro{length}
\newcommand{\circstate}{\cc{circ_state}}
\newcommand{\startIs}{\cc{start_is}}
\newcommand{\diskendIs}{\cc{end_is}}

\begin{itemize}
  \item $\circstate(\gamma, \sigma)$, which says that the current state
  of the circular buffer is $\sigma$. The $\gamma$ argument is a ``ghost name''
  for the ghost state associated with this instance of the circular buffer; at
  any time there is only one circular buffer, but this name will change every
  time the system crashes and reboots and thus distinguishes different
  ``generations'' of the circular buffer.
  \item $\cc{is_circular}(\gamma)$, defined to be
  $\knowInv{}{\exists \sigma, \circstate(\gamma, \sigma) * P(\sigma)}$.
  The $P(\sigma)$ part of this invariant is part of the HOCAP specification
  style, explained below.
  \item $\cc{circ_appender}(\gamma, \ell)$. This relates the circular buffer's
  ghost state with $\ell$, a \cc{*circularAppender} pointer that has some data
  needed to append to the circular buffer. This resource is not persistent and
  is owned by the logger thread.
  \item $\startIs(\gamma, \cc{start})$ and
  $\diskendIs(\gamma, \cc{end})$ give the exact current positions of the start
  and end (that is, $\sigma.\cc{start} + \length(\sigma.\cc{updates})$) of
  the circular buffer. These resources are not persistent and owned retained by
  the installer and logger threads respectively.
  \item $\cc{start_at_least}(\gamma, \cc{start})$ and
  $\cc{end_at_least}(\gamma, \cc{end})$ give \emph{lower bounds} on the start
  and end positions. It is possible to issue such resources because the start and
  end monotonically increase. As a result of monotonicity, these resources are
  persistent; once \cc{start} reaches some value that is always a valid lower
  bound.
\end{itemize}

\subsection{Specifications for Append and TrimTill}

Formally the way each operation is specified is using a style called
HOCAP~\cite{svendsen:hocap,jacobs:modular-lin}. The basic idea is that the
library maintains an invariant $P(\sigma)$, where $\sigma$ is the current
abstract state; a key idea in the HOCAP specification is that this predicate $P$
is chosen by the client. For each operation, the client passes in a
\emph{view-shift assertion} written $P(\sigma) \vs P(\sigma') * Q$, where the
transition from $\sigma$ to $\sigma'$ is a valid transition for the operation.
This view shift represents a kind of once-usable ``callback'' which transforms
$P(\sigma)$ into $P(\sigma')$, typically by updating the caller's ghost state in
$P$. At the end of the operation, the client receives $Q$ as a kind of
certificate that the callback ran. The intuition for why this specification
style captures linearizability is that the library does not know anything about
$P$ or $Q$ and thus the only way to preserve $P$ and produce $Q$ at the end is
to call the callback at exactly the linearization point of the operation.

We can see both the HOCAP pattern and the circular buffer resources in action in
the specification for Append:

\begin{align*}
  &\{ \cc{is_circular}(\gamma) \sep {} \\
&\quad (\forall \sigma, P(\sigma) \vs P(\sigma + \cc{upds}) * Q) \\
&\quad \cc{circ_appender}(\gamma, \cc{c}) \sep {} \\
&\quad \diskendIs(\cc{end}) \sep \cc{start_at_least}(\cc{start}) \sep (\cc{end} - \cc{start} + \length(\cc{upds}) \leq 511) \sep {} \\
&\} \\
&\qquad\cc{c.Append(end, upds)} \\
&\{ \diskendIs(\cc{end} + \length(\cc{upds})) \sep Q \}
\end{align*}

There are several aspects to the specification, mostly in the precondition. The
first line is the most straightforward: we need the circular buffer's invariant
to hold, for a particular ghost name $\gamma$. The second line is part of the
general HOCAP pattern. The view-shift updates $P(\sigma)$ to the appropriate new
state, noted as $\sigma + \cc{upds}$ as shorthand for $\sigma$ with \cc{upds}
appended to the updates field (and the same \cc{start}). The proof of this
specification executes the view shift at the linearization point of the \cc{Append}
operation, changing the state inside the $\cc{is_circular}$ invariant. The view
shift produces a user-supplied assertion $Q$ which is returned in the
postcondition.

The rest of the specification is specific to how the circular buffer manages
concurrency. Appending requires precise knowledge of the end position of the
circular buffer, which the logger thread maintains. A lower bound on the start
position is sufficient to prove that there is currently---and will continue to
be---enough space for the updates to fit on disk; the left-hand side of the
inequality computes an \emph{upper bound} on how much space will be used after
the append because the \cc{start} variable is a lower bound. The postcondition
gives the caller back the $\diskendIs$ assertion with the new precise end point.
Note that the precondition guarantees that the append will not fail due to
running out of space. Because the start and end are manipulated without locks
the circular buffer implementation does not even have a way to safely
dynamically check if there is enough space.

The specification for \cc{TrimTill} is similar to Append:

\begin{align*}
  &\{ \cc{is_circular}(\gamma) \sep {} \\
&\quad (\forall \sigma, P(\sigma) \vs P(\sigma[:\cc{newStart}]) * Q) \\
&\quad \startIs(\cc{start}) \sep \cc{end_at_least}(\cc{end}) \sep (\cc{start} \leq \cc{newStart} \leq \cc{end}) \sep {} \\
&\} \\
&\qquad\cc{c.TrimTill(newStart)} \\
&\{ \startIs(\cc{newStart}) \sep Q \}
\end{align*}

The effect of a \cc{TrimTill}, abbreviated $\sigma[:\cc{newStart}]$, is to set
the start position and delete the first $\cc{newStart} - \cc{start}$ updates.
This slightly unusual API permits a trivial implementation: the code simply
writes \cc{newStart} to disk. However, for this operation to be safe requires
that the start not go backwards (recall the Append proof relies on a lower bound
for \cc{start}) and not go past the current end position (concretely this would
logically delete updates that haven't yet been written!). The precondition
encodes these by taking a precise current \cc{start} position and a lower bound
on the end, and then requiring the new start variable be between the two. Just
like with Append, the installer thread that calls this operation always
maintains precise knowledge (ownership) of the start of the circular buffer.

Notice that neither of these specifications have a crash condition. The reason
this is not required is because both methods already maintain an invariant in
the \cc{is_circular} predicate, but formalizing this is a bit more
complicated.

\subsection{Crash and recovery reasoning}

The strategy behind proving crash safety is to prove a theorem about running a
whole system, restarting after every crash. For example, for DaisyNFS this
theorem applies to the server's main loop that receives a message from the
network, processes it in a background thread, and replies over the network.
Immediately following boot, before processing any requests, the server runs a
recovery procedure to restore in-memory state. This whole procedure --- recovery
followed by running the system --- gets an idempotent specification that is
proven with \ruleref{wpr-idempotence} from \autoref{sec:perennial:recovery}. The
crash condition for this theorem is a description of the state of the whole
system at any intermediate step; describing this directly would be daunting, but
it is doable since each layer describes its part of the crash condition.

The circular buffer is the lowest layer of the implementation, so the way it
fits into the larger plan is that the whole system's recovery starts by
recovering the circular buffer's state, then uses that state to recover the next
layer, and so on until the whole system is ready to run. Schematically this
looks like the following:

\begin{minted}[linenos]{go}
func RunSystem() {
  c, start, upds := recoverCircular()
  // recover rest of system from c, start, upds
  fs := recoverFilesystem(...)
  for {
    req := GetRequest()
    go func() {
      ret := fs.Handle(req)
      SendReply(req, ret)
    }
  }
}
\end{minted}

The circular buffer supplies three things to fit into the whole-system
idempotent proof: (1) an abstract crash predicate for the state the circular
buffer requires for recovery, (2) a crash specification for the circular
buffer's recovery procedure itself, and (3) a theorem that helps the caller
maintain the circular buffer's crash predicate.

The specification for recovery is:
%
\begin{align*}
  &\{ \circstate(\gamma, \sigma) \sep \cc{circ_resources}(\gamma) \} \\
  &\qquad\cc{recoverCircular()} \\
  &\{ \Ret{(\ell, \cc{diskStart}, \cc{upds})} \sigma = (\cc{diskStart}, \cc{upds}) \sep {} \\
  &\quad \circstate(\gamma, \sigma) \sep {}  \\
  &\quad \startIs(\cc{diskStart}) \sep \diskendIs(\cc{diskStart} + \cc{len}(\cc{upds})) \sep {} \\
  &\quad \cc{circ_appender}(\gamma, \ell) \} \\
  &\{ \circstate(\gamma, \sigma) \sep \cc{circ_resources}(\gamma) \}
\end{align*}
%
The first thing to notice about the recovery specification is that it preserves
$\circstate(\gamma, \sigma)$, which gives the current state of the circular
buffer, both on crash and if recovery completes. It is also the case that
$\cc{circ_appender}(\gamma, \ell) \proves \cc{circ_resources}(\gamma)$, so that
$\cc{circ_resources}(\gamma)$ is also preserved by recovery. These two together
are the crash predicate for the circular buffer. We say the crash predicate is
abstract because the user of this theorem does not need to know how it is
defined.

\newcommand{\cfupdw}{\mathrm{cfupd}}
\newcommand{\cfupd}[1]{\cfupdw\left(#1\right)}
\newcommand{\cinvw}{\mathrm{cinv}}
\newcommand{\cinv}[1]{\mathrm{cinv}\left(#1\right)}

The circular buffer's proof also supplies the following \emph{post-recovery
init} theorem, which sets up the circular buffer for use after recovery:
%
\begin{align*}
  &\forall \sigma, P(\sigma) \vs %
  P_{\mathrm{rec}}(\sigma) \sep %
  P_{\mathrm{crash}}(\sigma) \proves \\
  &\circstate(\gamma, \sigma) \sep P(\sigma) \vs \\
  &\exists \gamma'.\, \cc{is_circular}(\gamma) \sep {} \\
  &\quad \cfupd{ \exists \sigma.\, \circstate(\gamma', \sigma) \sep %
    \cc{circ_resources}(\gamma', \sigma) \sep %
    P_{\mathrm{rec}}(\sigma) } \sep {} \\
  &\quad \cinv{ \exists \sigma.\, \circstate(\gamma, \sigma) \sep %
    \cc{circ_exchanger}(\gamma, \gamma') \sep %
    P_{\mathrm{crash}}(\sigma) }
\end{align*}

There are several components to this theorem. First, the circular buffer has the
caller provide a way to split the HOCAP predicate $P(\sigma)$ into two parts,
$P_{\mathrm{rec}}(\sigma)$ and $P_{\mathrm{crash}}(\sigma)$ --- intuitively the
former is transferred to recovery as part of its crash condition, whereas the
latter is ``immutable'' and held inside an invariant. Second, the theorem
consumes $\circstate(\gamma, \sigma) \sep P(\sigma)$ and allocates three things:
(1) $\cc{is_circular}(\gamma)$ (notice that the premise of this theorem is the
contents of this invariant), (2) a ``$\cfupdw$'', and a (3) ``$\cinvw$''. The
latter two are low-level features of Perennial that we'll now introduce.

The assertion $\cfupd{R}$ (``crash fancy update'') is similar to a view-shift
$\TRUE \vs R$ in that it is a single-use update that produces the resources $R$.
However, the ``crash'' part indicates that this update can only be fired after a
crash, so it can be used to prove a crash condition but is otherwise unusuable.
Practically speaking, having $\cfupd{R}$ in a precondition allows the user to
\emph{cancel} $R$ from the proof's crash condition, as reflected in the
following rule:

\[
  \inferH{cfupd-use}
  {P \proves \wpc{e}{Q}{Q_{c}}}%
  {P \sep \cfupd{R} \proves \wpc{e}{Q}{Q_{c} \sep R}}
\]

In the context of the circular buffer, what the $\cfupdw$ sets up for the caller
is that if the system crashes, the recovery proof can dismiss the circular
buffer's crash predicate, along with $P_{\mathrm{rec}}(\sigma)$, from the
overall crash condition. Thus using \ruleref{cfupd-use} before running the
system both sets up the circular buffer for use (by establishing
$\cc{is_circular}(\gamma)$) and guarantees the circular buffer's part of the
crash condition from now on. Notice that the ghost name for the circular buffer
changes on crash to a new $\gamma'$; the reason for this is that other threads
(the logger and installer) have access to some of the circular buffer resources
associated with $\gamma$. Rather than requiring those threads to ``return''
those resources on crash and impose a crash condition on that code, we simply
create a new instance of the circular buffer and stop using the old one. As a
result on crash we can produce $\cc{circ_resources}(\gamma', \sigma)$ and hand
out these resources to the caller.

The third component of the theorem is a $\cinvw$ (``crash invariant'').
$\cinv{R}$ behaves very similarly to an invariant assertion $\knowInv{}{R}$, except
that like a crash fancy update it can only be used after a crash. This crash
invariant ``freezes'' the old state of the circular buffer (notice that
$\circstate(\gamma, \sigma)$ is now unchanging, since future operations will
interact with the instance named $\gamma'$). In the process we also maintain
some ghost state relating the old and new instances in the form of the
$\cc{circ_exchanger}(\gamma, \gamma')$ predicate. The circular buffer in
particular does not have an interesting exchanger predicate, but an interesting
use shows up in the GoJournal proof.

In general, each layer supplies a post-recovery init theorem. All of the layers' crash
obligation alt theorems are called after running all the recovery code just
before starting the system (that is, this would be just after line 4 in the
\cc{RunSystem()} code above). Calling these view shifts allocates all the layers'
invariants while simultaneously getting ``credit'' for this allocation in the
form of the $\cfupdw$ assertions, similar to how \ruleref{wpc-inv-alloc} works.
Prior to calling this initialization, the recovery procedure has access to the
inner contents of all the invariants, reflecting that it has exclusive access,
but in turn this proof is required to maintain a complicated crash condition.
(One interesting side effect is that recovery code can safely call library
functions without using locks, since this code is still guaranteed to be
single-threaded.) Once the system starts running the invariant allows multiple
threads to share access to this state, and the invariant implicitly guarantees
the crash condition recovery depends on.

The final aspect of our logically-atomic specification pattern is the role of
the exchanger, one of the conclusions of the post-recovery init theorem. The
purpose of this predicate is to give the caller a way to, on crash, relate
resources issued by the library before a crash to those after a crash. In the
circular buffer, the $\startIs(\cc{start})$ and $\diskendIs(\cc{end})$ resources
are thrown away on crash and re-created during recovery; there are only two of
them, so it easy enough to reconstruct them globally. In contrast, some
resources are used locally by a thread and we would like a way to retain
ownership across a crash, into that thread's crash condition. This is exactly
what happens with GoJournal's lifting-based specification, explained in greater
detail in \autoref{s:design}. Exchanging gives threads a way to ``trade''
ownership prior to a crash, associated with the old $\gamma$ instance, for
ownership after a crash, associated with $\gamma'$; this ownership can also be
exclusive, because the process destroys the old ownership and thus can only be
performed once.

To make this a bit more concrete, let us look at a part of the GoJournal lifting
specification. GoJournal issues three related resources: the two more important
ones are $a \mapsto_{d} o$ and $a \mapsto_{op} o$. Both represent exclusive
access to address $a$. $a \mapsto_{d} o$ is a durable statement about the
logical disk, while $a \mapsto_{op}$ gives the value at address $a$ from the
perspective of an in-progress operation $op$. The lifting-based specification
gets its name from a logical ``lift'' operation that trades $a \mapsto_{d} o$
for $a \mapsto_{op} o \sep a \mapsto_{d/2} o$. This brings us to the third type of
GoJournal resource, $a \mapsto_{d/2} o$ \tej{$d/2$ this is terrible notation,
want to convey ``disk without ownership''}, which is almost identical to
$a \mapsto_{d} o$ except that it cannot be used to lift again. We can give
Commit a (highly-simplified) specification like the following:
%
\begin{align*}
  \hoareCV{a \mapsto_{d/2} o \sep a \mapsto_{op} o'} %
  {\mathit{op}.\cc{Commit}()}%
  {\Ret{\mathit{ok}} \mathrm{if~} \mathit{ok} \mathrm{~then~} a \mapsto_{d} o' \mathrm{~else~} a \mapsto_{d} o}%
  {a \mapsto_{d} o \lor a \mapsto_{d} o'}
\end{align*}

This specification is simplified to only give the case of committing an
operation that modifies a single address, when in reality Commit's main purpose
is to atomically commit multiple addresses; a single address is enough to
understand the proof issues involved. If the system doesn't crash, it is
relatively straightforward to reverse the lifting process and restore full
ownership of the disk values. $a \mapsto_{d} o'$ reflects that the commit
actually succeeded in changing the disk value, while $a \mapsto_{d} o$ results
from aborting and throwing away buffered writes in $op$.

On crash it is more difficult to show $a \mapsto_{d} o \lor a \mapsto_{d} o'$.
The challenge is how to propagate whether or not the writes were made durable
from the lower-level abstractions up to this proof; indeed the durability of
this high-level operation depends on whether or not the lowest level of the
system, the circular buffer, successfully wrote a single header block!

The write-ahead logging layer conveys durability by issuing two resources: one
gives the history of multiwrites, and another gives a lower bound on how many
multiwrites are durable. Its exchanging resource allows the caller to trade an
assertion about the history before a crash for a similar assertion after a
crash, albeit with some recent writes lost. Crucially the effect of a crash is
constrained by the durable lower bound, which can also be exchanged across a
crash. On top of this exchanging, the journaling proof implements a fine-grained
exchange of ownership over individual addresses.

The actual implementation of exchanging uses a neat separation logic trick. To
distinguish between $a \mapsto_{d} o$ in two different generations, we'll
annotate the resource with a $\gamma$. The exchanger for the journaling proof is
defined in terms of facts like:
\[
  \cc{exchange_addr}(a) \defeq (a \mapsto^{\gamma}_{d} o) \lor (a \mapsto^{\gamma'}_{d} o)
\]
When proving the post-recovery init theorem, we initially prove
$\cc{exchange_addr}(a)$ using the right-hand side; this is easy since $\gamma'$
is fresh, so we've just allocated all of its associated ghost state and it
hasn't been used by any threads so far. We can then prove exchange lemmas like
$a \mapsto^{\gamma}_{d} o \sep \cc{exchange_addr}(a) \proves a \mapsto^{\gamma'}_{d} o \sep \cc{exchange_addr}(a)$.
The reason this proof works is that $a \mapsto_{d} o$ is \emph{exclusive}, thus
from the premise we can rule out that $\cc{exchange_addr}(a)$ is proven with the
left disjunct and learn that the right-hand side holds. We take out this
right disjunct ($a \mapsto^{\gamma'}_{d} o$) and give up
$a \mapsto^{\gamma'}_{d} o$ re-prove $\cc{exchange_addr}(a)$, this time using
the left disjunct. This all ensures that exchanging is only performed once,
which is necessary since all the resources involved are exclusive.

% look at \cc{exchange_mapsto_commit} for the interesting case (ephemeral values
% that might now be durable) and \cc{exchange_durable_mapsto} for the
% straightforward case (durable values that are now proven to still be durable,
% exchanger shows old lower bounds are still valid)

\subsection{Summary}

The overall logically-atomic crash specification pattern has four components for
every layer of the system:

\begin{itemize}
  \item An opaque predicate for the abstract state of the system (e.g.,
        $\circstate(\gamma, \sigma)$).
  \item Proofs for each operation that use a client-specified predicate,
        modified by requiring a view shift that updates the predicate in
        accordance with the operation's effect on abstract state.
  \item An opaque crash predicate for the system.
  \item A recovery theorem, with a crash condition, that preserves the crash
  predicate for the system and re-builds any in-memory state needed.
  \item A post-recovery init theorem, to be called after the whole system has
        recovered, which sets up the layer's invariant for normal execution,
        creates ghost state for the next generation, and produces an exchanger
        resource to relate the old state to the new one.
\end{itemize}

When layers are composed, the upper layer will generally subsume the recovery
and post-recovery init theorems in its own proof.

This pattern can be combined with user-defined ghost resources in order to give
more powerful specifications (rather than requiring every operation to be
unconditionally atomic). User-defined ghost resources can interact with crashes
and recovery; for example, they can be returned from the recovery theorem and
used across a crash using exchanging lemmas specific to the library.
