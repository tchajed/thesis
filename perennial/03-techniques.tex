\section{Reasoning techniques in Perennial}
\label{sec:perennial:techniques}

On top of the Perennial logic, we developed some techniques to organize proofs
of libraries and compose them. Of particular interest is a pattern for
\emph{logically-atomic crash specifications}, which capture that a set of
methods in a library appear atomic with respect to both other threads and on
crash. In order to illustrate how all of these techniques work together, this
section walks through the specification and proof intuition for the circular
buffer, a library used in GoTxn that has interesting crash safety and
concurrency behavior. This library operates directly on top of the disk, so no
background on GoTxn is needed to understand it.

The circular buffer (``circ'' for short) is essentially an on-disk queue of
updates, which are pairs of an address and a disk block. It is used to implement
write-ahead logging: disk writes are first stored in the circular buffer, and
then eventually moved to a separate data region. It supports two operations
during normal usage: \cc{Append(upds)} appends a list of updates to the buffer
and \cc{TrimTill(pos)} deletes updates up to \cc{pos}. Queue positions grow
indefinitely, but the buffer can hold at most 511 updates at a time and it
is the caller's responsibility to avoid overflowing with \cc{Append}. The only
read operation is recovery, which restores the durable updates and current queue
position; in practice the contents are cached, but this is the caller's concern.

There are three challenges in giving the circ library a specification. First, we
want to show that \cc{Append} appears to be atomic to the caller, even though it
internally writes many disk blocks. Second, the library has some thread-safety
requirements to enforce on the caller: in particular \cc{Append} and
\cc{TrimTill} can be called concurrently from separate threads, but it is not
safe to overlap multiple appends or multiple trim requests. Finally, the library
relies on the caller to guarantee that append and trim are called with enough
available space. These last two challenges are due to leaving concurrency
control to the caller, which is more efficient than the circular buffer having
its own redundant locking.

The basic idea is that the circular buffer is specified in terms of an abstract
state that evolves through an atomic transition for each operation. Recovery can
recover the pre-crash state of the buffer. The state for this library consists
of two components: a list of updates (which are pairs of an address to write to
and a 4KB block to write there) and a 64-bit start position that indicates how
many updates occurred prior to the current list of updates. Append, as
mentioned, simply appends to the list of updates. The argument to \cc{TrimTill}
is a position of this form; the effect of \cc{TrimTill(pos)} is to delete
\cc{pos - start} updates from the beginning of the list of updates and set the
new start position to \cc{pos}.

The circular buffer has the following API:

\begin{minted}{go}
func InitCircular() *circAppender
func (c *circAppender) Append(end uint64, upds []Update)
func TrimTill(start uint64)}
func RecoverCircular() (c *circAppender,
        start uint64, upds []Update)
\end{minted}

The write-ahead log uses the circular buffer from two threads, one dedicated to
\emph{logging} which appends to the circular buffer to make writes durable and another
dedicated to \emph{installation} which trims writes from the circular buffer
after installing them. Appending and trimming can be performed concurrently, but
appending requires the \cc{*circAppender} struct which is not thread-safe. The
caller only reads from the circular buffer if the system crashes, at which point
recovery restores the previous state. During normal operation the caller keeps a
separate in-memory cache of the entries in the circular buffer.

The specifications use the following separation logic resources issued by the
circular buffer:

\newidentmacro{length}

\begin{itemize}
  \item $\cc{circular_state}(\gamma, \sigma)$, which says that the current state
  of the circular buffer is $\sigma$. The $\gamma$ argument is a ``ghost name''
  for the ghost state associated with this instance of the circular buffer; at
  any time there is only one circular buffer, but this name will change every
  time the system crashes and reboots and thus distinguishes different
  ``generations'' of the circular buffer.
  \item $\cc{is_circular}(\gamma)$, defined to be
  $\knowInv{}{\exists \sigma, \cc{circular_state}(\gamma, \sigma) * P(\sigma)}$.
  The $P(\sigma)$ part of this invariant is part of the HOCAP specification
  style, explained below.
  \item $\cc{circ_appender}(\gamma, \ell)$. This relates the circular buffer's
  ghost state with $\ell$, a \cc{*circularAppender} pointer that has some data
  needed to append to the circular buffer. This resource is not persistent and
  is owned by the logger thread.
  \item $\cc{start_is}(\gamma, \cc{start})$ and
  $\cc{end_is}(\gamma, \cc{end})$ give the exact current positions of the start
  and end (that is, $\sigma.\cc{start} + \length(\sigma.\cc{updates})$) of
  the circular buffer. These resources are not persistent and owned retained by
  the installer and logger threads respectively.
  \item $\cc{start_at_least}(\gamma, \cc{start})$ and
  $\cc{end_at_least}(\gamma, \cc{end})$ give \emph{lower bounds} on the start
  and end positions. It is possible to issue such resources because the start and
  end monotonically increase. As a result of monotonicity, these resources are
  persistent; once \cc{start} reaches some value that is always a valid lower
  bound.
\end{itemize}

Formally the way each operation is specified is using a style called
HOCAP~\cite{svendsen:hocap,jacobs:modular-lin}. The basic idea is that the
library maintains an invariant $P(\sigma)$, where $\sigma$ is the current
abstract state; a key idea in the HOCAP specification is that this predicate $P$
is chosen by the client. For each operation, the client passes in a
\emph{view-shift assertion} written $P(\sigma) \vs P(\sigma') * Q$, where the
transition from $\sigma$ to $\sigma'$ is a valid transition for the operation.
This view shift represents a kind of once-usable ``callback'' which transforms
$P(\sigma)$ into $P(\sigma')$, typically by updating the caller's ghost state in
$P$. At the end of the operation, the client receives $Q$ as a kind of
certificate that the callback ran. The intuition for why this specification
style captures linearizability is that the library does not know anything about
$P$ or $Q$ and thus the only way to preserve $P$ and produce $Q$ at the end is
to call the callback at exactly the linearization point of the operation.

We can see both the HOCAP pattern and the circular buffer resources in action in
the specification for Append:

\begin{align*}
  &\{ \cc{is_circular}(\gamma) \sep {} \\
&\quad (\forall \sigma, P(\sigma) \vs P(\sigma + \cc{upds}) * Q) \\
&\quad \cc{circ_appender}(\gamma, \cc{c}) \sep {} \\
&\quad \cc{end_is}(\cc{end}) \sep \cc{start_at_least}(\cc{start}) \sep (\cc{end} - \cc{start} + \length(\cc{upds}) \leq 511) \sep {} \\
&\} \\
&\qquad\cc{c.Append(end, upds)} \\
&\{ \cc{end_is}(\cc{end} + \length(\cc{upds})) \sep Q \} \\
\end{align*}

There are several aspects to the specification, mostly in the precondition. The
first line is the most straightforward: we need the circular buffer's invariant
to hold, for a particular ghost name $\gamma$. The second line is part of the
general HOCAP pattern. The view-shift updates $P(\sigma)$ to the appropriate new
state, noted as $\sigma + \cc{upds}$ as shorthand for $\sigma$ with \cc{upds}
appended to the updates field (and the same \cc{start}). The proof of this
specification executes the view shift at the linearization point of the \cc{Append}
operation, changing the state inside the $\cc{is_circular}$ invariant. The view
shift produces a user-supplied assertion $Q$ which is returned in the
postcondition.

The rest of the specification is specific to how the circular buffer manages
concurrency. Appending requires precise knowledge of the end position of the
circular buffer, which the logger thread maintains. A lower bound on the start
position is sufficient to prove that there is currently---and will continue to
be---enough space for the updates to fit on disk; the left-hand side of the
inequality computes an \emph{upper bound} on how much space will be used after
the append because the \cc{start} variable is a lower bound. The postcondition
gives the caller back the \cc{end_is} assertion with the new precise end point.
Note that the precondition guarantees that the append will not fail due to
running out of space. Because the start and end are manipulated without locks
the circular buffer implementation does not even have a way to safely
dynamically check if there is enough space.

The specification for \cc{TrimTill} is similar to Append:

\begin{align*}
  &\{ \cc{is_circular}(\gamma) \sep {} \\
&\quad (\forall \sigma, P(\sigma) \vs P(\sigma[:\cc{newStart}]) * Q) \\
&\quad \cc{start_is}(\cc{start}) \sep \cc{end_at_least}(\cc{end}) \sep (\cc{start} \leq \cc{newStart} \leq \cc{end}) \sep {} \\
&\} \\
&\qquad\cc{c.TrimTill(newStart)} \\
&\{ \cc{start_is}(\cc{newStart}) \sep Q \} \\
\end{align*}

The effect of a \cc{TrimTill}, abbreviated $\sigma[:\cc{newStart}]$, is to set
the start position and delete the first $\cc{newStart} - \cc{start}$ updates.
This slightly unusual API permits a trivial implementation: the code simply
writes \cc{newStart} to disk. However, for this operation to be safe requires
that the start not go backwards (recall the Append proof relies on a lower bound
for \cc{start}) and not go past the current end position (concretely this would
logically delete updates that haven't yet been written!). The precondition
encodes these by taking a precise current \cc{start} position and a lower bound
on the end, and then requiring the new start variable be between the two. Just
like with Append, the installer thread that calls this operation always
maintains precise knowledge (ownership) of the start of the circular buffer.

\tej{things to figure out from the circular buffer/WAL proofs:}
\begin{enumerate}
  \item why does \cc{crash_obligation_alt} have both a cfupd and an invariant in
  the postcondition?
  \item how does a lower bound on the write-ahead log sequence of disks before a
crash get turned into knowledge after the crash in the Commit specification?
\end{enumerate}

\resume
