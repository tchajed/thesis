This chapter is about Goose, which solves a practical
problem of reasoning about efficient code. To use Goose, a developer writes
code in Go, uses an automatic translator to convert the code to a model in the Coq proof
assistant, then carries out the proof on top of the model in the Perennial logic. Goose encompasses
the entire process: it includes the translation tool itself, the way it models Go
code, and finally the reasoning principles for proving properties of translated
Go. (We will also use ``Goose'' in some places to refer to the subset of Go
supported by the translation tool.)

This chapter is intentionally fairly independent of the rest of the thesis for a
reader interested in verifying Go code but not crash safety or the specifics of
the GoTxn and DaisyNFS proofs. Crashes are modeled simply by stopping
execution and wiping out all of the state except for the disk, which does not
relate to the specifics of Go.

\input{goose/01-goals.tex}
\input{goose/02-related.tex}
\input{goose/03-overview.tex}
\input{goose/04-lang.tex}
\input{goose/05-features.tex}
\input{goose/06-reasoning.tex}
\input{goose/07-testing.tex}

\section{Conclusion}

Goose is an approach for verifying Go code. We define GooseLang as a model of Go
and automatically translate a subset of Go to this language. GooseLang comes
with a number of reasoning principles for handling features of Go. The benefit
of this approach is the flexbility to write high-performance code in a
productive language, while also getting convenient reasoning while verifying
that code. Several aspects of the design contribute to making the approach
sound, ranging from the subset of Go supported, to the design of GooseLang, and
the use of standard Go tools for analyzing the source code.

Our main use case for Goose for this thesis was to verify GoTxn, but we believe
the tool and approach are more generally applicable, even without concurrency or
crash-safety reasoning. These ideas could also be productively applied to
languages other than Go --- I am personally excited about the prospect of having
a version for Rust.\footnote{I think the translator for Rust to Coq should be
called Roost.}
