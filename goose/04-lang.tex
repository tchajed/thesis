\section{GooseLang syntax and semantics}%
\label{sec:goose:semantics}

\newcommand{\goosedef}[1]{\mathsf{#1}}
\newcommand{\goosekw}[1]{\goosedef{\textcolor{blue}{#1}}}
% spacing for application
\newcommand{\app}{\:}
% any pure binary op
\newcommand{\binop}{\circledcirc}
% any pure unary op
\newcommand{\unop}{\circleddash}

\newcommand{\external}{\mathsf{\textcolor{red}{\langle External \rangle}}}

\newcommand{\gooseif}[3]{\goosekw{if} \app #1 \app%
  \goosekw{then} \app #2 \app \goosekw{else} \app #3}

\newcommand{\recfx}{\goosekw{rec} \, f(x) = e}
\newcommand{\gooselambda}[1]{\goosekw{\lambda}#1.\,}

\newcommand{\reduces}{\rightsquigarrow}
\newcommand{\purereduction}{\overset{\mathrm{pure}}{\reduces}}

\newcommand{\seq}{;\,}
\newcommand{\defeq}{\triangleq}

GooseLang is an effectful, untyped lambda calculus, with mutable references and
concurrency. Defining the language involves defining a \emph{syntax} in the form
of expressions, and a \emph{semantics} for how those expressions execute in the
form of a transition system. The transitions also require some state, for
example to track the value stored at each allocated pointer. This language has
low-level primitives for modeling an imperative program, with nothing terribly
Go-specific; we will give a high-level overview in this section and details in
\autoref{sec:goose:reasoning}.

The basic unit of the language is the expression $e$, which supports recursive
functions $\recfx$ and basic data types like tuples $(e_1, e_2)$. Then, we give
these expressions a semantics in terms of the reduction relation
$(\sigma, e) \reduces (\sigma', e')$ which says that $e$ reduces to (or executes
to) $e'$ in the state $\sigma$, and the resulting state is $\sigma'$. This
reduction relation is eventually lifted to not just a single expression but a
whole \emph{threadpool}, a collection of concurrently-executing expressions. You
can think of each expression as representing the computation of a single thread,
and each reduction step as being running the thread for one transition. The
granularity of these transitions corresponds to what is considered atomic
between threads. For a reader unfamiliar with operational semantics for the
lambda calculus, X is a good reference \tej{figure out what to recommend for
  lambda calculus}.

\begin{figure}[ht!]
  \textbf{Syntax}
  \begin{mathpar}
  \begin{array}{llcl}
    &x,f &\in &\textdom{Var} \\
    &\ell &\in &\textdom{Loc} \\
    &n &\in & \textdom{U64} \cup \textdom{U32} \cup \textdom{U8} \\
    &s &\in &\textdom{String} \\
    &\binop &::= & + \ALT - \ALT * \ALT = \ALT < \ALT \dots \\
    &\unop &::= & - \ALT \goosekw{ToString} \ALT \goosekw{ToU64} \ALT
                         \dots \\
    \textdom{Var}& v &::= & () \ALT \goosekw{true} \ALT \goosekw{false} \ALT n
                            \ALT \ell \ALT s \\
    &&\ALT & \goosekw{inj}_1 \app v \ALT \goosekw{inj}_2 \app v \ALT
             \recfx \\
    \textdom{Exp}& e &::= & x \ALT v \ALT e \app e %
                            \ALT \goosekw{Fork}(e)
                            \ALT \goosekw{Panic}(s)
                            \ALT \recfx \\
    &&\ALT & \gooseif{e}{e}{e} \\
    &&\ALT & (e, e) \ALT \pi_1 \app e \ALT \pi_2 \app e \\
    &&\ALT & \goosekw{inj}_1 \app e \ALT \goosekw{inj}_2 \app e
    \ALT %
      \goosekw{case} \app e \app \goosekw{of} \app \goosekw{inj}_1 \app x
      \Rightarrow e \app \goosekw{or} \app \goosekw{inj}_2 \app x \Rightarrow e
    \\
    &&\ALT & e \binop e \ALT \unop e \ALT \goosekw{ArbitraryU64} \\
    &&\ALT & \goosekw{AllocN}(e, e)
             \ALT \goosekw{CmpXchg}(e, e, e) %
             \ALT \goosekw{Load}(e) \\
    &&\ALT & \goosekw{PrepareWrite}(e) %
             \ALT \goosekw{FinishStore}(e, e) %
             \ALT \goosekw{StartRead}(e) %
             \ALT \goosekw{FinishRead}(e) \\
    &&\ALT & \external \\
  \end{array}
  \end{mathpar}

  \textbf{Derived forms and notation}
  \begin{mathpar}
  \begin{array}{rcl}
    \gooselambda{x} e &\defeq & \goosekw{rec} \: \_(x) = e \\
    \gooselambda{x, y} e &\defeq & \gooselambda{x} \gooselambda{y} e \\
    \goosekw{let} \: x = e_1 \app \goosekw{in} \app e_2 %
                             &\defeq &%
                                   (\goosekw{\lambda} x.\, e_2) \app e_1 \\
    e_1\seq e_2 &\defeq &%
                   \goosekw{let} \: \_ = e_1 \app \goosekw{in} \app e_2 \\
    \goosekw{ref} \app e &\defeq &\goosekw{AllocN}(1, e) \\
    !x &\defeq & \goosekw{Load}(x) \\
    \goosedef{Store} &\defeq & \gooselambda{x, e} \goosekw{PrepareWrite}(x);
                               \goosekw{FinishStore}(x, e) \\
    x \gets e &\defeq & \goosedef{Store} \app x \app e \\
    % \goosekw{do}\,\goosekw{while} \app e &\defeq &%
    %                         (\goosekw{rec} \: loop(\_) = \gooseif{e \app ()}{loop
    %                         \app ()}{()}) \app () \\
  \end{array}
  \end{mathpar}
  \caption{GooseLang syntax}
  \label{goose:syntax}
\end{figure}

Before going into the semantics for these expressions, we can build intuition by
looking at some very simple Go programs and their translations into GooseLang.
First, we can write some \emph{pure} functions that don't use pointers:

\begin{minipage}{0.4\textwidth}
\begin{minted}{go}
func Midpoint(x uint64,
              y uint64) uint64 {
  return (x + y) / 2
}

func Max(x uint32,
         y uint32) uint32 {
  if x > y { return x }
  return y
}
\end{minted}
\end{minipage}%
%
\begin{minipage}{0.5\textwidth}
\begin{align*}
  &\goosedef{Midpoint} \defeq \gooselambda{x, y} (x + y) /2 \\
  \\
  &\goosedef{Max} \defeq \gooselambda{x, y} \\
  &\quad \gooseif{x > y}{x}{y} \\
\end{align*}
\end{minipage}

\begin{minipage}{0.4\textwidth}
\begin{minted}{go}
func Arith(a uint64,
           b uint64) uint64 {
  sum := a + b
  if sum == 7 { return a }
  mid := Midpoint(a, b)
  return mid
}
\end{minted}
\end{minipage}%
%
\begin{minipage}{0.5\textwidth}
\begin{align*}
  &\goosedef{Arith} \defeq \gooselambda{a, b} \\
  &\quad\goosekw{let} \app sum = a + b \app\goosekw{in}\app \\
  &\quad\goosekw{if} \app sum = 7 \app\goosekw{then}\app a \app\goosekw{else} \\
  &\quad\quad \goosekw{let} \app mid = \goosedef{Midpoint}\app a \app b \app\goosekw{in}\\
  &\quad\quad mid \\
\end{align*}
\end{minipage}

Notice that the translation maps each Go function to a GooseLang definition. For
readability the GooseLang definitions are written mathematically, but what the
Goose tool actually emits is a Coq file where each definition is a Gallina term
of type \cc{expr} (the type of GooseLang expressions). This is what allows
definitions to refer to each other, such as how $\goosedef{Arith}$ calls the
previously defined $\goosedef{Midpoint}$.

The next interesting feature of GooseLang is support for pointers. In this
aspect the language is a bit unusual; we get to the reasons why in
\autoref{sec:goose:pointers}. For now, it is sufficient to think of $x \gets e$
as the usual pointer store operation, and $!x$ as the usual load. Here are a couple
examples to illustrate:

\begin{minipage}{0.4\textwidth}
\begin{minted}{go}
func Swap(x *uint64, y *uint64) {
  tmp := *x
  *x = *y
  *y = tmp
}

func NewPtr() *uint64 {
  return new(uint64)
}
\end{minted}
\end{minipage}%
%
\begin{minipage}{0.5\textwidth}
\begin{align*}
  &\goosedef{Swap} \defeq \gooselambda{x, y} \\
  % these {} are needed so LaTeX spaces the ! correctly, rather than putting it
  % next to the = or \gets
  &\quad\goosekw{let} \app tmp = {} !x \app\goosekw{in}\app \\
  &\quad x \gets {} !y \\
  &\quad y \gets tmp\\
  \\
  &\goosedef{NewPtr} \defeq \gooselambda{\_} \\
  &\quad \goosekw{ref} \app 0
\end{align*}
\end{minipage}

The $\goosedef{NewPtr}$ definition might need some explanation. First, even
though the Go code takes no arguments, the GooseLang expression takes an unused
argument; this is so that $\goosedef{NewPtr}$ is syntactically a function, a
requirement of the way GooseLang is encoded in Coq.\footnote{For expert readers,
GooseLang functions are actually \emph{values} and not expressions.} Second,
this definition allocates a pointer with $\goosekw{ref}$, using
$\goosekw{AllocN}$ which more generally allocates $n$ contiguous pointers. The
initial value of 0 is the ``zero value'' of the \cc{uint64} type, a promise made
by Go.

\begin{figure}[hp]
  \textbf{Pure reduction}%
  \hfill %
  \boxedassert[line width=0.4pt]{e \purereduction e'} %
  \hspace{20pt}

  \begin{mathpar}
  \begin{array}{rcll}
    v \binop v' &\purereduction & v'' & \mathrm{if} \: v'' = v \binop v' \\
    \unop v &\purereduction & v' & \mathrm{if} \: v' = \unop v \\
    \gooseif{\goosekw{true}}{e_1}{e_2} &\purereduction & e_1 \\
    \gooseif{\goosekw{false}}{e_1}{e_2} &\purereduction & e_2 \\
    \pi_i(v_1, v_2) &\purereduction &v_i \\
    \goosekw{case} \app \goosekw{inj}_i v \app\goosekw{of}\app %
    \goosekw{inj}_1 \app x_1 \Rightarrow e_1 \app\goosekw{or}\app%
    \goosekw{inj}_2 \app x_2 \Rightarrow e_2%
                &\purereduction & \subst{e_i}{x_i}{v} \\
    (\recfx) \app v &\purereduction & \subst{\subst{e}{f}{(\recfx)}}{x}{v} \\
    \goosekw{ArbitraryInt} &\purereduction &n & \forall n \in \textdom{U64} \\
  \end{array}
  \end{mathpar}

  \newcommand{\mapupd}[2]{[#1 \mapsto #2]}

  \textbf{Semantics preliminary definitions}
  \begin{mathpar}
  \begin{array}{llcl}
    \textdom{ECtx}& E &::= & \square \ALT E \app v \ALT e \app E  %
                             \ALT E \binop e \ALT v \binop E \ALT \unop E \ALT \\
                  &&\ALT & \gooseif{E}{e}{e} \\
                  &&\ALT & (E, e) \ALT (v, E) \ALT \pi_i \app E \ALT
                           \goosekw{inj}_i \app E \\
                  &&\ALT & \goosekw{AllocN}(E, e) \ALT \goosekw{AllocN}(v, E)
                           \ALT \dots \\
    \textdom{NonAtom}& z &::= & \goosekw{Reading} \app n \app v \ALT
                                \goosekw{Writing} \app v \\
    \textdom{Heap}& h &\in& \textdom{Loc} \overset{\mathrm{fin}}{\to}
                        \textdom{NonAtom} \\
    \textdom{World}& w & & \external  \\
    %\textdom{State}& \sigma &::= (h, w) \\
    \textdom{TPool}& \mathcal{E} &\in &\textdom{List}\app\textdom{Exp} \\
    %\textdom{Config}& \rho &::= (\sigma, \mathcal{E}) \\
  \end{array}
  \end{mathpar}


  \textbf{Per-thread one-step reduction}%
  \hfill %
  \boxedassert[line width=0.4pt]{((h, w), e) \reduces ((h', w'), e') } %
  \hspace{20pt}

  \begin{mathpar}
  \begin{array}{rcll}
    ((h, w), e) &\reduces & ((h, w), e') &\mathrm{if} \: e \purereduction e' \\
    ((h, w), \goosekw{CmpXchg}(\ell, v_1, v_2)) &\reduces %
                          &((h\mapupd{\ell}{v_2}, w), (v, \goosekw{true}))%
                                         &\mathrm{if} \: h(\ell) =
                                           \goosekw{Reading} \app 0 \app v \land
    v = v_1 \\
    ((h, w), \goosekw{CmpXchg}(\ell, v_1, v_2)) &\reduces %
                          &((h, w), (v, \goosekw{false}))%
                                         &\mathrm{if} \: h(\ell) =
                                           \goosekw{Reading} \app 0 \app v \land
                                           v \neq v_1 \\
    ((h, w), \goosekw{AllocN}(n, v)) &\reduces %
                          &((h[\ell + i \mapsto v \mid 0 \leq i < n], w), \ell) %
                                         &\mathrm{if} \: \forall 0 \leq i < n,
                                           \, \ell + i \notin \dom(h) \\
    ((h, w), \goosekw{PrepareWrite}(\ell)) &\reduces %
                          &((h\mapupd{l}{\goosekw{Writing} \app v}, w), ()) %
                                         &\mathrm{if} \: h[\ell] = \goosekw{Reading} \app 0
                                           \app v \\
    ((h, w), \goosekw{FinishStore}(\ell, v)) &\reduces %
                          &((h\mapupd{l}{\goosekw{Reading} \app 0 \app v}, w), ()) %
                                         &\mathrm{if} \: h[\ell] =
                                           \goosekw{Writing} \app v' \\
    ((h, w), \goosekw{StartRead}(\ell)) &\reduces %
                          &((h\mapupd{l}{\goosekw{Reading} \app (n+1) \app v}, w), ()) %
                                         &\mathrm{if} \: h[\ell] =
                                           \goosekw{Reading} \app n \app v \\
    ((h, w), \goosekw{FinishRead}(\ell)) &\reduces %
                          &((h\mapupd{l}{\goosekw{Reading} \app n \app v}, w), v) %
                                         &\mathrm{if} \: h[\ell] =
                                           \goosekw{Reading} \app (n+1) \app v \\
    ((h, w), \goosekw{Load}(\ell)) &\reduces %
                          &((h, w), v) &\mathrm{if} \: %
                                         h[\ell] = \goosekw{Reading} \app n \app v \\
  \end{array}
  \end{mathpar}

  \textbf{Context reduction}%
  \hfill%
  \boxedassert[line width=0.4pt]{((h, w), \mathcal{E}) \reduces ((h', w'), \mathcal{E}')}%
  \hspace{20pt}

  \begin{mathpar}
    \inferH{context-reduce}%
    {((h, w), e) \reduces ((h,', w'), e') \\ \text{$E$ is an evaluation context}}%
    {((h, w), \mathcal{E}\mapupd{i}{E[e]}) \reduces%
      ((h', w'), \mathcal{E}\mapupd{i}{E[e']})}

    \inferH{fork-reduce}%
    {j \notin \dom(\mathcal{E}) \cup \{j\} \\ \text{$E$ is an evaluation context}}%
    {((h, w), \mathcal{E}\mapupd{i}{E[\goosekw{Fork}(e)]}) \reduces%
      ((h, w), \mathcal{E}\mapupd{i}{E[()]}\mapupd{j}{e})
    }
  \end{mathpar}

  \caption{GooseLang semantics}%
  \label{goose:semantics}
\end{figure}

\begin{figure}[ht]
  \textbf{Disk operations}
  \begin{mathpar}
  \begin{array}{ccc}
    e &::= & \dots \ALT \goosekw{DiskRead}(e) \ALT \goosekw{DiskWrite}(e, e)
             \ALT \goosekw{DiskSize} \\
  \end{array}
  \end{mathpar}
  \textbf{Disk external semantics}
  \begin{mathpar}
  \begin{array}{lccc}
    \textdom{Block} & b &\in& \textdom{Vec} \app 4096 \app \textdom{U8} \\
    \textdom{World} & w &\in & \mathbb{N} \overset{\mathrm{fin}}{\to}
                               \textdom{Block} \\
  \end{array}
  \end{mathpar}

  \begin{mathpar}
    \infer{\forall 0 \leq i < 4096,\, \ell + i \notin \dom(h) \\ w[a] = b}%
    {((h, w), \goosekw{DiskRead}(a)) \reduces%
      ((h[\ell + i \mapsto \goosekw{Reading} \app 0 \app b[i] %
      \mid 0 \leq i < 4096], w), \ell)}

    \infer{\forall 0 \leq i < 4096,\, \exists k.\, h[\ell + i] =
      \goosekw{Reading} \app k \app b[i] }
    {((h, w), \goosekw{DiskWrite}(a, \ell)) \reduces %
      ((h, w[a \mapsto b]), ())}

    \infer{}%
    {((h, w), \goosekw{DiskSize}) \reduces %
    ((h, w), 1 + \textlog{max} \app \dom(w))}
  \end{mathpar}
  \caption{Syntax and semantics for an external disk}
\end{figure}

\tej{also need to describe Hoare triples and separation logic, might as well do
that here since it's part of the foundations of reasoning about GooseLang}

\resume

\clearpage
