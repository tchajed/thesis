\section{GooseLang syntax and semantics}%
\label{sec:goose:lang}

\newcommand{\goosedef}[1]{\mathsf{#1}}
\newcommand{\goosekw}[1]{\ensuremath{\goosedef{\textcolor{blue}{#1}}}}
% spacing for application
\newcommand{\app}{\:}
% any pure binary op
\newcommand{\binop}{\circledcirc}
% any pure unary op
\newcommand{\unop}{\circleddash}

\newcommand{\external}{\mathsf{\textcolor{red}{\langle External \rangle}}}

\newcommand{\goosetrue}{\goosekw{true}}
\newcommand{\goosefalse}{\goosekw{false}}

\newcommand{\gooseif}[3]{\goosekw{if} \app #1 \app%
  \goosekw{then} \app #2 \app \goosekw{else} \app #3}

\newcommand{\recfx}{\goosekw{rec} \, f(x) = e}
\newcommand{\gooselambda}[1]{\goosekw{\lambda}#1.\,}

\newcommand{\reduces}{\rightsquigarrow}
\newcommand{\purereduction}{\overset{\mathrm{pure}}{\reduces}}

\newcommand{\seq}{;\,}
\newcommand{\defeq}{\triangleq}

GooseLang is an effectful, untyped lambda calculus, with mutable references and
concurrency. Defining the language involves defining a \emph{syntax} in the form
of expressions, and a \emph{semantics} for how those expressions execute in the
form of a transition system. The transitions also require some state, for
example to track the value stored at each allocated pointer. This language has
low-level primitives for modeling an imperative program, with nothing terribly
Go-specific; we will give a high-level overview in this section and details in
\cref{sec:goose:reasoning}.

The basic unit of the language is the expression $e$, which supports recursive
functions $\recfx$ and basic data types like tuples $(e_1, e_2)$. Then, we give
these expressions a semantics in terms of the reduction relation
$(\sigma, e) \reduces (\sigma', e')$ which says that $e$ reduces to (or executes
to) $e'$ in the state $\sigma$, and the resulting state is $\sigma'$. This
reduction relation is eventually lifted to not just a single expression but a
whole \emph{threadpool}, a list of concurrently executing expressions. You
can think of each expression as representing the computation of a single thread,
and each reduction step as being running the thread for one transition. The
granularity of these transitions corresponds to what is considered atomic
between threads. For a reader unfamiliar with the lambda calculus, you can find
a detailed introduction in the textbook \emph{Types and Programming
Languages}~\cite[Chapter~5]{pierce:tapl}.

\begin{figure}[hp!]
  \textbf{Syntax}
  \begin{mathpar}
  \begin{array}{llcl}
    &x,f &\in &\textdom{Var} \\
    &\ell &\in &\textdom{Loc} \\
    &n &\in & \textdom{U64} \cup \textdom{U32} \cup \textdom{U8} \\
    &s &\in &\textdom{String} \\
    &\binop &::= & + \ALT - \ALT * \ALT = \ALT < \ALT \dots \\
    &\unop &::= & - \ALT \goosekw{ToString} \ALT \goosekw{ToU64} \ALT
                         \dots \\
    \textdom{Var}& v &::= & () \ALT \goosetrue \ALT \goosefalse \ALT n
                            \ALT \ell \ALT s \\
    &&\ALT & \goosekw{inj}_1 \app v \ALT \goosekw{inj}_2 \app v \ALT
             \recfx \\
    \textdom{Exp}& e &::= & x \ALT v \ALT e \app e \ALT \recfx \\
    &&\ALT & \gooseif{e}{e}{e} \\
    &&\ALT & \goosekw{Fork}(e) \\
    &&\ALT & (e, e) \ALT \pi_1 \app e \ALT \pi_2 \app e \\
    &&\ALT & \goosekw{inj}_1 \app e \ALT \goosekw{inj}_2 \app e
    \ALT %
      \goosekw{case} \app e \app \goosekw{of} \app \goosekw{inj}_1 \app x
      \Rightarrow e \app \goosekw{or} \app \goosekw{inj}_2 \app x \Rightarrow e
    \\
    &&\ALT & e \binop e \ALT \unop e \ALT \goosekw{ArbitraryU64} \\
    &&\ALT & \goosekw{AllocN}(e, e)
             \ALT \goosekw{CmpXchg}(e, e, e) %
             \ALT \goosekw{Load}(e) \\
    &&\ALT & \goosekw{PrepareWrite}(e) %
             \ALT \goosekw{FinishStore}(e, e) %
             \ALT \goosekw{StartRead}(e) %
             \ALT \goosekw{FinishRead}(e) \\
    &&\ALT & \goosekw{Panic}(s) \\
    &&\ALT & \external
  \end{array}
  \end{mathpar}

  \textbf{Derived forms and notation}
  \begin{mathpar}
  \begin{array}{rcl}
    \gooselambda{x} e &\defeq & \goosekw{rec} \: \_(x) = e \\
    \gooselambda{x, y} e &\defeq & \gooselambda{x} \gooselambda{y} e \\
    \goosekw{let} \: x = e_1 \app \goosekw{in} \app e_2 %
                             &\defeq &%
                                   (\goosekw{\lambda} x.\, e_2) \app e_1 \\
    e_1\seq e_2 &\defeq &%
                   \goosekw{let} \: \_ = e_1 \app \goosekw{in} \app e_2 \\
    \goosekw{ref} \app e &\defeq &\goosekw{AllocN}(1, e) \\
    !x &\defeq & \goosekw{Load}(x) \\
    \goosedef{Store} &\defeq & \gooselambda{x, e} \goosekw{PrepareWrite}(x);
                               \goosekw{FinishStore}(x, e) \\
    x \gets e &\defeq & \goosedef{Store} \app x \app e \\
    % \goosekw{do}\,\goosekw{while} \app e &\defeq &%
    %                         (\goosekw{rec} \: loop(\_) = \gooseif{e \app ()}{loop
    %                         \app ()}{()}) \app () \\
  \end{array}
  \end{mathpar}
  \caption{GooseLang syntax}
  \label{fig:goose:syntax}
\end{figure}

The syntax for GooseLang programs is given in \cref{fig:goose:syntax}. The
important top-level definition is $e \in \textdom{Exp}$, giving expressions in
GooseLang. Before getting to the expressions, it's worth noting that the values
in GooseLang are designed for Go's primitive data, in particular with
first-class support for bytes and 32-bit and 64-bit unsigned integers. We did
not need signed integers and so did not model them, but adding them would simply
require extending the type of literals and adding many more pure operations to
implement various integer conversions.

The basic lambda calculus primitives are given on the first line: variables $x$,
values $v$, function application $e \app e$, and (recursive) functions $\recfx$.
The first few derived forms encode more basic primitives like a non-recursive
lambda, let bindings, and sequencing, all on top of recursive functions. The
language has two types of composite data: products (used pervasively to model
structs), and sums (used only to model maps). There is also $\goosekw{if}$ as the
main control-flow primitive, and $\goosekw{Fork}$ to create concurrent threads.
Finally, there are many primitives for the heap, which are discussed in more
detail later.

We can build intuition for both the syntax and semantics of GooseLang by looking
at some very simple Go programs and their translations into GooseLang. First,
let's look at some \emph{pure} functions that don't use pointers:

\newcommand{\translaterule}{\rule{0.9\textwidth}{0.5pt}}

\newenvironment{translatego}{
  \noindent
  \translaterule \\[-10pt]
  % get proper top alignment
  % https://tex.stackexchange.com/questions/378548/vertical-alignment-of-side-by-side-minipages
  \begin{minipage}[t]{0.5\textwidth}
  \strut\vspace*{-\baselineskip}
  \setminted[go]{frame=none}
}{
  \end{minipage}
  \setminted[go]{frame=lines}
}

\newenvironment{translategooselang}{
  \begin{minipage}[t]{0.5\textwidth}
  \strut\vspace*{-8pt}
}{
  \end{minipage}
  \\[5pt] \translaterule
}

\begin{translatego}
\begin{minted}{go}
func Midpoint(x uint64,
              y uint64) uint64 {
  return (x + y) / 2
}
\end{minted}
\end{translatego}
%
\begin{translategooselang}
  \begin{flalign*}
  &\goosedef{Midpoint} \defeq \gooselambda{x, y} (x + y) /2 &
  \end{flalign*}
\end{translategooselang}

\begin{translatego}
\begin{minted}{go}
func Max(x uint32,
         y uint32) uint32 {
  if x > y { return x }
  return y
}
\end{minted}
\end{translatego}
%
\begin{translategooselang}
  \begin{flalign*}
  &\goosedef{Max} \defeq \gooselambda{x, y} & \\
  &\quad \gooseif{x > y}{x}{y} &
  \end{flalign*}
\end{translategooselang}

\begin{translatego}
\begin{minted}{go}
func Arith(a uint64,
           b uint64) uint64 {
  sum := a + b
  if sum == 7 { return a }
  mid := Midpoint(a, b)
  return mid
}
\end{minted}
\end{translatego}%
%
\begin{translategooselang}
\begin{flalign*}
  &\goosedef{Arith} \defeq \gooselambda{a, b} & \\
  &\quad\goosekw{let} \app sum = a + b \app\goosekw{in}\app & \\
  &\quad\goosekw{if} \app sum = 7 \app\goosekw{then}\app a \app\goosekw{else} & \\
  &\quad\quad \goosekw{let} \app mid = \goosedef{Midpoint}\app a \app b \app\goosekw{in} &\\
  &\quad\quad mid &
\end{flalign*}
\end{translategooselang}

Notice that the translation maps each Go function to a GooseLang definition. For
readability the GooseLang definitions are written mathematically, but what the
Goose tool actually emits is a Coq file where each definition is a Gallina term
of type \cc{expr} (the type of GooseLang expressions). This is what allows
definitions to refer to each other, such as how $\goosedef{Arith}$ calls the
previously defined $\goosedef{Midpoint}$.

The next interesting feature of GooseLang is support for pointers. In this
aspect the language is a bit unusual; we get to the reasons why in
\cref{sec:goose:pointers}. For now, it is sufficient to think of $x \gets e$
as the usual pointer store operation, and $!x$ as the usual load. Here are a couple
examples to illustrate:

\begin{translatego}
\begin{minted}{go}
func Swap(x *uint64,
          y *uint64) {
  tmp := *x
  *x = *y
  *y = tmp
}
\end{minted}
\end{translatego}
%
\begin{translategooselang}
\begin{flalign*}
  &\goosedef{Swap} \defeq \gooselambda{x, y} & \\
  % these {} are needed so LaTeX spaces the ! correctly, rather than putting it
  % next to the = or \gets
  &\quad\goosekw{let} \app tmp = {} !x \app\goosekw{in}\app \\
  &\quad x \gets {} !y \\
  &\quad y \gets tmp
\end{flalign*}
\end{translategooselang}

\begin{translatego}
\begin{minted}{go}
func NewPtr() *uint64 {
  return new(uint64)
}
\end{minted}
\end{translatego}
%
\begin{translategooselang}
\begin{flalign*}
  &\goosedef{NewPtr} \defeq \gooselambda{\_} \goosekw{ref} \app 0 &
\end{flalign*}
\end{translategooselang}

The $\goosedef{NewPtr}$ definition might need some explanation. First, even
though the Go code takes no arguments, the GooseLang expression takes an unused
argument; this is so that $\goosedef{NewPtr}$ is syntactically a function, a
requirement of the way GooseLang is encoded in Coq.\footnote{For expert readers,
GooseLang functions are actually \emph{values} and not expressions.} Second,
this definition allocates a pointer with $\goosekw{ref}$, using
$\goosekw{AllocN}$ which more generally allocates $n$ contiguous pointers. The
initial value of 0 is the ``zero value'' of the \cc{uint64} type, a promise made
by Go.

The Goose syntax includes an $\external$ alternative. The language, both syntax
and semantics, are parameterized over an external interface of operations, for
interacting with the outside world. For example, in GoTxn the code uses an
interface of external disk operations, presented separately in
\cref{fig:goose:disk-ffi}. The parameterization is primarily useful for
refinement proofs that relate Goose with one set of external operations to
another (for example, we use this to specify GoTxn). Other than that use case,
the reader can imagine that the external rules are simply part of the definition
of expressions and the semantics.

Goose also has a formal, small-step operational semantics; this style of
specification and indeed most of the semantics is quite standard for languages of
this type. The full details are presented in \cref{fig:goose:semantics}.

\begin{figure}[hp]
  \textbf{Pure reduction}%
  \hfill %
  \boxedassert[line width=0.4pt]{e \purereduction e'} %
  \hspace{20pt}

  \begin{mathpar}
  \begin{array}{rcll}
    v \binop v' &\purereduction & v'' & \mathrm{if} \: v'' = v \binop v' \\
    \unop v &\purereduction & v' & \mathrm{if} \: v' = \unop v \\
    \gooseif{\goosetrue}{e_1}{e_2} &\purereduction & e_1 \\
    \gooseif{\goosefalse}{e_1}{e_2} &\purereduction & e_2 \\
    \pi_i(v_1, v_2) &\purereduction &v_i \\
    \goosekw{case} \app \goosekw{inj}_i v \app\goosekw{of}\app %
    \goosekw{inj}_1 \app x_1 \Rightarrow e_1 \app\goosekw{or}\app%
    \goosekw{inj}_2 \app x_2 \Rightarrow e_2%
                &\purereduction & \subst{e_i}{x_i}{v} \\
    (\recfx) \app v &\purereduction & \subst{\subst{e}{f}{(\recfx)}}{x}{v} \\
    \goosekw{ArbitraryInt} &\purereduction &n & \forall n \in \textdom{U64} \\
  \end{array}
  \end{mathpar}

  \textbf{Per-thread head reduction}%
  \hfill %
  \boxedassert[line width=0.4pt]{((h, w), e) \reduces ((h', w'), e') } %
  \hspace{20pt}
  %
  \begin{mathpar}
  \begin{array}{llcl}
    \textdom{NonAtom}& z &::= & \goosekw{Reading} \app n \app v \ALT
                                \goosekw{Writing} \app v \\
    \textdom{Heap}& h &\in& \textdom{Loc} \overset{\mathrm{fin}}{\to}
                        \textdom{NonAtom} \\
    \textdom{World}& w & & \external  \\
    %\textdom{State}& \sigma &::= (h, w) \\
    \textdom{TPool}& \mathcal{E} &\in &\textdom{List}\app\textdom{Exp} \\
    %\textdom{Config}& \rho &::= (\sigma, \mathcal{E}) \\
  \end{array}

  \begin{array}{rcll}
    ((h, w), e) &\reduces & ((h, w), e') &\mathrm{if} \: e \purereduction e' \\
    ((h, w), \goosekw{CmpXchg}(\ell, v_1, v_2)) &\reduces %
                          &((h\mapupd{\ell}{v_2}, w), (v, \goosetrue))%
                                         &\mathrm{if} \: h(\ell) =
                                           \goosekw{Reading} \app 0 \app v \land
    v = v_1 \\
    ((h, w), \goosekw{CmpXchg}(\ell, v_1, v_2)) &\reduces %
                          &((h, w), (v, \goosefalse))%
                                         &\mathrm{if} \: h(\ell) =
                                           \goosekw{Reading} \app 0 \app v \land
                                           v \neq v_1 \\
    ((h, w), \goosekw{AllocN}(n, v)) &\reduces %
                          &((h[\ell + i \mapsto v \mid 0 \leq i < n], w), \ell) %
                                         &\mathrm{if} \: \forall 0 \leq i < n,
                                           \, \ell + i \notin \dom(h) \\
    ((h, w), \goosekw{PrepareWrite}(\ell)) &\reduces %
                          &((h\mapupd{l}{\goosekw{Writing} \app v}, w), ()) %
                                         &\mathrm{if} \: h[\ell] = \goosekw{Reading} \app 0
                                           \app v \\
    ((h, w), \goosekw{FinishStore}(\ell, v)) &\reduces %
                          &((h\mapupd{l}{\goosekw{Reading} \app 0 \app v}, w), ()) %
                                         &\mathrm{if} \: h[\ell] =
                                           \goosekw{Writing} \app v' \\
    ((h, w), \goosekw{StartRead}(\ell)) &\reduces %
                          &((h\mapupd{l}{\goosekw{Reading} \app (n+1) \app v}, w), ()) %
                                         &\mathrm{if} \: h[\ell] =
                                           \goosekw{Reading} \app n \app v \\
    ((h, w), \goosekw{FinishRead}(\ell)) &\reduces %
                          &((h\mapupd{l}{\goosekw{Reading} \app n \app v}, w), v) %
                                         &\mathrm{if} \: h[\ell] =
                                           \goosekw{Reading} \app (n+1) \app v \\
    ((h, w), \goosekw{Load}(\ell)) &\reduces %
                          &((h, w), v) &\mathrm{if} \: %
                                         h[\ell] = \goosekw{Reading} \app n \app v \\
  \end{array}
  \end{mathpar}

  \textbf{Context reduction}%
  \hfill%
  \boxedassert[line width=0.4pt]{((h, w), \mathcal{E}) \reduces ((h', w'), \mathcal{E}')}%
  \hspace{20pt}

  \begin{mathpar}
  \begin{array}{llcl}
    \textdom{ECtx}& E &::= & \square \ALT e \app E \ALT E \app v  %
                             \ALT E \binop e \ALT v \binop E \ALT \unop E \ALT \\
                  &&\ALT & \gooseif{E}{e}{e} \\
                  &&\ALT & (E, e) \ALT (v, E) \ALT \pi_i \app E \ALT
                           \goosekw{inj}_i \app E \\
                  &&\ALT & \goosekw{AllocN}(E, e) \ALT \goosekw{AllocN}(v, E)
                           \ALT \dots
  \end{array}

    \inferH{context-reduce}%
    {((h, w), e) \reduces ((h,', w'), e') \\ \text{$E$ is an evaluation context}}%
    {((h, w), \mathcal{E}\mapupd{i}{E[e]}) \reduces%
      ((h', w'), \mathcal{E}\mapupd{i}{E[e']})}

    \inferH{fork-reduce}%
    {j \notin \dom(\mathcal{E}) \cup \{j\} \\ \text{$E$ is an evaluation context}}%
    {((h, w), \mathcal{E}\mapupd{i}{E[\goosekw{Fork}(e)]}) \reduces%
      ((h, w), \mathcal{E}\mapupd{i}{E[()]}\mapupd{j}{e})
    }
  \end{mathpar}

  \caption{GooseLang semantics}%
  \label{fig:goose:semantics}
\end{figure}

\paragraph{Structure of the semantics}
The semantics is a lot to take in, especially if you've never seen such a
presentation. The semantics is defined in three relations: the first, the
\emph{pure reduction relation} $e \purereduction e'$, is the easiest to understand
because it describes ``pure'' expressions that do not depend on any external
state. The semantics of such expression is simply to ``reduce'' to simpler
expressions, eventually reaching values. The semantics of function application
is pure. We use $\subst{e}{x}{v}$ as notation for \emph{substituting} the expression
$v$ for the variable $x$ in $e$. To implement recursion, the function definition
is itself substituted for its name.

Next, we define the semantics of the heap operations. This relation is over
$((h, w), e)$. $h$ is the heap and $e$ is the expression being executed; $w$ is
the type of an external ``world'' that is used to define the semantics of
external operations. Even the type of this world state is a parameter at this
level, and is defined as part of defining a set of external operations and their
semantics. The specific case of the disk is presented in
\cref{fig:goose:disk-ffi}.

Finally, we define the full semantics over $((h, w), \mathcal{E})$. Instead of a
single expression, we now have a \emph{threadpool}, a list of expressions, all
running concurrently. This semantics is presented in a standard style using
\emph{evaluation contexts} --- you can find an explanation in a simpler setting
in \emph{Practical Foundations for Programming Languages}~\cite[\S 5.3]{harper:pfpl}. The
previous relation involving a single expression is called a \emph{head reduction
  relation} because it only gives the semantics of expressions where the
relevant operation is at the top level or ``head'' of the expression, and when
applied to values (notice for example that the rule for $\goosekw{AllocN}(n, v)$
is only defined when applied to a number and a value, not other expressions).
Context reductions are how those arguments get executed when we run something
like $\goosekw{AllocN}(10, \goosetrue \| \goosefalse)$.

Context reductions are defined by a type of evaluation contexts
$\textdom{ECtx}$. Rather than going through the details of how these are used
(the rule \ruleref{context-reduce}), here I'll just explain intuitively what
evaluation contexts are. Every context $E$ is an expression with a ``hole'' in
it, indicating where the next reduction should take place. The entire expression
might be a hole $\square$. As an example, the pair of contexts $E \binop e$ and
$v \binop E$ determine how all binary operators work (for example, $\binop$
might be $+$). These say that if we have an expression $e_{1} \binop e_{2}$, we can
always run the argument $e_{1}$ (due to the first context), but it must execute
to a value before we evaluate the second argument (the second context). Once
both are values, the pure reduction for binary operators will apply. The result
is a left-to-right evaluation order for binary operators.

GooseLang does have one extant bug related to evaluation contexts. The contexts
$e \app E$ and $E \app v$ define a right-to-left evaluation order for functions,
which is the opposite of Go. We haven't yet fixed this, either by adjusting the
GooseLang semantics or changing the translation to emit code that explicitly
evaluates all the arguments in the correct order before calling the function.

\begin{figure}[ht]
  \textbf{Disk operations}
  \begin{mathpar}
  \begin{array}{ccc}
    e &::= & \dots \ALT \goosekw{DiskRead}(e) \ALT \goosekw{DiskWrite}(e, e)
             \ALT \goosekw{DiskSize} \\
  \end{array}
  \end{mathpar}
  \textbf{Disk external semantics}
  \begin{mathpar}
  \begin{array}{lccc}
    \textdom{Block} & b &\in& \textdom{Vec} \app 4096 \app \textdom{U8} \\
    \textdom{World} & w &\in & \mathbb{N} \overset{\mathrm{fin}}{\to}
                               \textdom{Block} \\
  \end{array}
  \end{mathpar}

  \begin{mathpar}
    \infer{\forall 0 \leq i < 4096,\, \ell + i \notin \dom(h) \\ w[a] = b}%
    {((h, w), \goosekw{DiskRead}(a)) \reduces%
      ((h[\ell + i \mapsto \goosekw{Reading} \app 0 \app b[i] %
      \mid 0 \leq i < 4096], w), \ell)}

    \infer{\forall 0 \leq i < 4096,\, \exists k.\, h[\ell + i] =
      \goosekw{Reading} \app k \app b[i] }
    {((h, w), \goosekw{DiskWrite}(a, \ell)) \reduces %
      ((h, w[a \mapsto b]), ())}

    \infer{}%
    {((h, w), \goosekw{DiskSize}) \reduces %
    ((h, w), 1 + \textlog{max} \app \dom(w))}
  \end{mathpar}
  \caption{Syntax and semantics for an external disk.}
  \label{fig:goose:disk-ffi}
\end{figure}

\clearpage
