\section{High-level overview}

The goal of the translation is to model a Go program using GooseLang,
which is a programming language defined in Coq for this purpose. When we
say GooseLang is a programming language, we mean it in a theoretical
sense: GooseLang consists of a type of programs in Coq and a small-step
semantics of these programs. Since GooseLang programs support references
to model the Go heap, the semantics is written in terms of transitions
of (program, heap) pairs where the heap maps pointers to values. The
intention of the translation is that the semantics of the translated
function should cover all the behaviors of the Go code, in terms of
return values and effect on the heap. As long as this is true, a proof
that the translated code always satisfies some specification means that
the real running code will, too.

GooseLang is a low-level language, so many constructs in Go translate to
(small) implementations in GooseLang. This implementation choice proved
to be much more convenient than adding primitives to the language for
every Go construct. For example, a slice is represented as a tuple of
pointer, length, and capacity, and appending to a slice requires
checking for available capacity and copying if none is available.
Appending to a slice is a complicated operation, and it was easier to
write it correctly as a program rather than directly as a transition in
the semantics. The one cost to this design strategy is that an arbitrary
GooseLang program is much more general than translated Go programs. This
has no impact on verifying any \emph{specific} Go program.

The extra generality of GooseLang does have some downsides since at one point in
the development, in the transaction system's specification, we refer to an
arbitrary GooseLang program. This theorem is made a bit more complicated since
to there are some ill-defined GooseLang programs that no Go program could
generate which the theorem needs to exclude. The transaction system
specification uses a standard technique of restricting to well-typed GooseLang
programs, and encoding syntactic restrictions in that type system.

\tej{add a diagram, perhaps like the ones in the Goose talk, showing the
translation process and how Go/Goose/GooseLang all fit together}

An important aspect of GooseLang is supporting interactive proofs on top
of the translated code. The interactive proofs use separation logic, a
variant of Hoare logic, so specifications describe the behavior of each
individual function. In order to support verification of any translated
code, GooseLang comes with a specification for any primitive or function
that the translated code might refer to, including libraries like slices
used to model more sophisticated Go features. GooseLang has many
``pure'' operations that have no effect on the heap, due to many
primitive data types and operations (for example, there are both 8-,
32-, and 64-bit integers, and arithmetic and logical operations for
each). The specifications for these operations are handled with a single
lemma, which is applied automatically with a tactic \cc{wp_pures}.

Since our goal is to support interactive rather than automated proofs,
it is helpful to make the model simple to work with. We try to maintain
a strong correspondence between the model and source code: each Go
package translates to a single Coq file, and each top-level declaration
in the Go code maps to a Gallina definition (a GooseLang constant or
function). Goose has a special case for translating immutable variables
to let bindings in GooseLang (rather than allocating a pointer that will
only be read). As a result, factoring out a sub-expression to a variable
has little impact on proofs, since it just adds one more pure step.

While the model is simple in terms of control flow and structure, we can
safely translate any given Go operation to a sophisticated model as long
as the proof abstracts it away. The subsequent sections in this chapter
walk through several features of Go. In each case we first implement the
feature in GooseLang, which as a model of its behavior primarily aims to
be faithful to Go. Next, we develop reasoning principles for the
features, in the form of separation logic assertions (for example, to
represent a slice) and Hoare triples (for example, to specify the
behavior of Append). The key is that the model is trusted to capture
Go's behavior so some sophistication is useful, whereas the reasoning
principles aim to hide that complexity to make proofs practical.
