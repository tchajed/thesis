\section{Supported and unsupported features}

\tej{what is the point of this chapter? move the positive parts to high-level
  overview, rest to limitations}

Each function is translated to a single Coq definition, which is a
GooseLang function. For concurrency, Goose supports the \cc{go}
statement and the synchronization primitives \cc{*sync.Mutex} and
\cc{sync.Cond}.

Go's primitive uint64, uint32, uint8 (byte), and boolean types are all
supported, as well as most of the pure functions on those types. Goose
also supports pointers, structs, and methods on structs. Finally, Goose
supports Go's built-in data structures, slices and maps.

Control flow is slightly tricky since a Go function is translated
to a single GooseLang expression that should evaluate to the function's
return value. Goose supports many specific patterns, especially common
cases like early returns inside \cc{if} statements and loops with
\cc{break} and \cc{continue}, but more complex control flow ---
particularly returning from within a loop --- is not supported. If we
wanted to fix this the right solution would probably be to represent all
functions in continuation-passing style, though this would complicate
the translation of every function call.
