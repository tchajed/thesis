\subsection{How to read this thesis}

\Cref{ch:daisy-nfs} describes the programming interface, specification,
implementation, and proof for the overall file system. When describing the
implementation and proof, a significant component is the transaction system,
which we only give an interface and specification for. The details of that proof
are in \cref{ch:txn}. The transaction system's proof required two
contributions that are part of this thesis. \Cref{ch:goose} is optional
reading on how the proof connects to the code. \Cref{ch:perennial} gives
background needed to understand how the proof itself works.

\subsection{Intro stuff}

For the file-system implementation and proof, we use the Dafny
verification language. The file-system operations interact with the
transaction system to store and retrieve data. To run the system, we
compile the Dafny code to Go, which imports and calls into the
transaction system as a library. Dafny only supports sequential
reasoning, which is sufficient at this layer because the transaction
system guarantees that the Dafny code appears to run sequentially. In contrast
with Perennial, Dafny is an automated reasoning framework, resulting in simpler
and more productive proofs in this layer.

Using Perennial for the transaction system and Dafny for the file-system
operations lets us use the sharpest tool for each part of the proof. However, it
introduces a challenge in the proof: it is not obvious how to connect a verified
transaction system with the Dafny proof. This thesis develops an appropriate
specification for the transaction system and then links the Dafny proof with the
transaction system's specification, to
argue that the linked code is correct. This linking theorem has a proof which stitches together
the Dafny and Coq proofs, so that all of the code is verified with a
machine-checked proof but we verify the system using two very different proof
systems.

While in the introduction we have given nearly equal weight to the transaction
system and the file-system implementation, much more of the thesis is about
verifying the transaction system. The transaction system is more complex than
the file-system design, largely by design: the transaction system uses novel
verification techniques whereas the file-system
design explicitly aims to make the higher-level proofs simple and sequential.
Furthermore the transaction system involved new infrastructure that is part of
this thesis, both the program logic and Goose, our tool for connecting the
implementation to the proof.

\subsection{Related work}

The overall file system relies heavily on the transaction system to
lower the proof burden, isolating the tricky crash safety and concurrency
reasoning to a generic system and then verifying the file-system operations with
sequential proofs. Transactions are not fundamental to correctly implementing a
file system: notably Featherstitch~\cite{frost:featherstitch} offers a
principled way to think about correctness without transactions, while
B$e$trFS~\cite{jannen:betrfs} and the production btrfs file systems use
copy-on-write as the core atomicity primitive. However, our rigorous use of
transactions is amenable to a simpler proof since we can show that transactions
are atomic once, independent of the actual code written on top. Furthermore this
design makes the file system easy to grow over time since further development
just involves writing more sequential code and proofs.
