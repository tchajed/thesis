\section{Implementation}
\label{s:impl}

Perennial 2.0 is a re-write of the Perennial 1.0 framework~\cite{chajed:perennial}, implemented on top of
Goose~\cite{chajed:perennial, chajed:goose-coqpl},
Iris~\cite{jung:iris-jfp,jung:iris-1}, and Coq~\cite{coq}.  \Cref{fig:syslines}
shows the lines of specifications and proof for Perennial.  Perennial extends
the Iris Proof Mode~\cite{krebbers:ipm} to support convenient interactive
proofs in Coq for crashes and Perennial's atomic crash specifications.

\begin{figure}
\centering
\small
\begin{tabular}{lr}
\toprule
\bf Component & \bf Lines of Coq \\
\midrule
  \input{go-journal/tables/perennial-loc.tex}
\end{tabular}
\caption{Lines of specs and proofs for Perennial.}
\label{fig:syslines}
\end{figure}

Perennial's program logic for crashes provides the formal foundations for
framing away crash conditions and for atomic crash specifications.
Lifting is implemented as part of the helper libraries.  Ghost resources
implement lock-free concurrent reasoning, including
monotonic counters (to track log positions in \cref{fig:log}) and
multi-versioned disks (to track logical disk contents at crash time
for disk-object ownership).

Using \txn, we implemented \gnfs and its core verified subset,
\simplenfs.  Both implementations can be mounted by the
Linux NFS client, which translates file-system calls into NFS RPCs.
\gnfs is sufficiently complete that it can run fsstress and fsx-linux
tests through the Linux NFS client.

The breakdown of lines of code and proof by layer, as seen in \cref{fig:loc},
shows a proof-to-code ratio of about $20\times$ for the layers that involve
tricky crash safety and concurrency reasoning. Notably the \simplenfs proof is
relatively short due to the \txn implementation and specification largely hiding
crash reasoning. The \textsc{wal} and \textsc{jrnl} layers are split into two
parts for proof purposes; the layers labeled ``STS'' are specified with an
atomic state-transition system while the next layer presents an easier-to-use
ownership-based interface using separation logic. The write-ahead log's proof is
largely in establishing its atomic transitions, while half of the top-level \txn
proof is proving its separation logic specification as described in
\cref{s:design}.

All of the proofs for Perennial, \txn, and \simplenfs are checked by Coq, and we
used \cc{Print Assumptions} to verify that the proofs are complete.  The
code is publicly available.\footnote{GoJournal is available at
\url{https://github.com/mit-pdos/go-journal} while \gnfs and \simplenfs are at
\url{https://github.com/mit-pdos/go-nfsd}.}


\begin{figure}
\centering
\small
\begin{tabular}{lrrr}
\toprule
  & \bf Lines of code & \bf Lines of proof & \bf Ratio \\
  & (Go) & (Coq) & \\
\midrule
  \input{go-journal/tables/impl-loc.tex} \\
\bottomrule
\end{tabular}
\caption{Lines of code and proof for the components of \txn and for
\simplenfs. Ratio is the proof:code ratio, a rough measure of verification overhead.}
\label{fig:loc}
\end{figure}



% One proof challenge for sub-block objects is \txn's support for
% \emph{bit-sized} objects, which are useful for implementing a file
% system's block and inode allocators using a bitmap stored in a disk
% block. Installing a modification to a bit is conceptually not too
% difficult, but the actual code implementing it must use low-level bit
% operations:
%
% \input{go-journal/code/installBit}
%
% To specify this function, we implemented functions \cc{byte_to_bits} and
% \cc{bit_to_bytes} to convert back and forth between \cc{u8} (represented
% as an integer between 0 and $2^8$) and \cc{list bool}. Then, we can
% write a simple functional specification for \cc{installBit}:
%
% \input{go-journal/code/installBit_spec}
%
% The proof that the code implements this specification is quite difficult
% using only properties of arithmetic, but since this code operates on
% bytes that can only have 256 possible values and bit offsets that are
% between 0--8, the proof simply considers all possible values of \cc{dst},
% \cc{bit}, and the bit at \cc{bit} in \cc{src}, a total of 4096 cases
% (Coq is a bit too slow to handle the 130K cases from simply considering
% all possible values for the three arguments).
