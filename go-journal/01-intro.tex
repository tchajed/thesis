\section{Introduction}

\tej{rewrite the GoJournal introduction to introduce journaling and transactions
together (and of course remove all the stuff about ``this paper'')}


Storage systems, such as file systems, need to be carefully structured
to not lose persistent user data, even in the face of application and
whole-system crashes. They often achieve this \emph{crash safety}
property by delegating writing to storage to a \emph{journaling
system}, which exposes an API for executing an operation such that its
writes appear on disk atomically. The journaling system simplifies
implementing the storage system's logic: to atomically modify a set of
objects, the file system simply writes to them one at a time within a single
journal operation.  The result is that each storage operation is atomic with
respect to crashes.

While a journaling system exposes a simple API, its implementation must address
crash safety and also be concurrent for good performance.
Maintaining correctness in the presence of both concurrency and crashes is
challenging.  For example, in pursuit of performance, journaling systems
often avoid holding locks while performing I/O, but reasoning
about the correctness of such optimizations requires considering what
happens if one thread's disk reads interleave with another thread's
disk writes, and what happens when the system crashes anywhere
during that interleaving.

% \mfk{we should make clear that \txn is a Go package.}
This paper presents \txn, a Go package that provides the first formally verified concurrent journaling
system. To verify \txn, we developed Perennial 2.0, an extension to the Perennial~\citep{chajed:perennial} framework
with several features designed to enable modular reasoning about concurrent, crash-safe systems.
In this work we set a goal of giving
\txn a specification that \emph{reflects the simplicity of using a journal for
crash atomicity}.
\txn can be used by an application like a file system or a key-value
store. As long as the application follows a locking discipline
for its on-disk state, such as per-file locks for a file system, proving the correctness
and crash-safety of that implementation on top of \txn should involve
largely \emph{sequential} reasoning, despite the fact that the application
has multiple concurrent threads and can crash at any time.

\tej{no longer need to say anything about application reasoning, only proving
the GoTxn spec}
Realizing this goal raises two challenges: specifying \txn in a way that makes
application reasoning sequential, and proving \txn's implementation correct. The
specification makes reasoning about an operation sequential with a
\emph{lifting} interface where the proof has an abstraction of a ``checked out''
private fragment of the disk that the operation appears to synchronously modify.
At commit time the private fragment is ``checked in'', at which point it is
durable and can be exposed to other threads. The journal guarantees the
operation is atomic by delaying all writes to commit time, so the developer
should not need to explicitly reason about crash safety until commit time.
Perennial 2.0 supports a new technique called \emph{crash framing} to formalize
the intuition that during an operation the developer need not explicitly
consider crash safety.

The second challenge lies in proving \txn itself.  This is
difficult because we desire modularity to make the system's proof tractable,
which requires giving suitable specifications to the internal interfaces of the system.
While the user-visible interface of \txn is simple, the
internal interfaces of a high-performance journaling system are
hard to specify and fit together.
To address this challenge, Perennial 2.0 contributes \emph{logically atomic crash
  specifications} which enable natural specifications of system layers in terms of
a transition system with
atomic transitions for the public methods.
These specifications include a \emph{crash transition}
to describe what happens to the state of a layer during a crash.
% These specifications both intuitively correspond to atomicity
% and are precise enough
Such specifications make it possible to build upper layers of the system on top without
worrying about implementation details of how atomic transitions are achieved.
This separation of concerns lines up with the modularity in the implementation;
the proof layers divide up the reasoning along the same lines that the
code divides up functionality among Go packages.
% Furthermore, we needed
% to incorporate a \emph{crash transition} into the transition system to specify exactly
% what data can be lost on crash, since some of the internal APIs of \txn buffer
% data in memory before persisting it. \mfk{I don't understand this last
%   sentence. And, I would like to avoid another ``we''}

% The internal API makes it difficult to achieve the desired strong
% specification of atomic transactions. The reason the strong specification
% holds is due to the use of locks to protect disk-object ownership. Under
% these ownership assumptions, the journaling system can prove that the
% internal APIs behave atomically with a single logical commit point.

% We implemented \sys on top of Perennial~\cite{chajed:perennial}, a
% concurrent crash-safe verification framework.  We then implemented
% \txn and used \sys to formally specify and prove its correctness and
% crash safety; in the process of doing so we found one design bug that
% was not caught by unit tests (\S\ref{sec:eval:bugs}).

Although \txn is advanced enough to support a high-performance NFS
server, it has some limitations.  \txn's internals (code and proof)
support deferred durability, but for simplicity, \txn's top-level
specification requires applications to immediately flush committed
journal operations, which is sufficient to prove \simplenfs.  \txn is also
less general than JBD2 (e.g., \txn does not support floating commit
blocks), and less general than database transaction systems (e.g.,
\txn does not support undoing journaled operations).

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "paper.tex"
%%% End:
