\section{GoTxn's specification}

At a high level, GoTxn's specification says that transactions execute
atomically. The way this is stated formally is by considering an arbitrary
caller, a program that has transactions using the GoTxn API. Then correctness is
defined by relating this executable code to an abstract, specification program,
a version of the caller code where the GoTxn methods are treated as primitives.
An important aspect of GoTxn is that the specification program is defined using
an atomic block around each transaction, whose semantics is to run the body
without interleaving other threads.

Before we can get to defining these specification programs, we first set up
\emph{refinement}, which is the relationship between the code and spec.
Abstractly, refinement from a code program to
a specification program says that the behaviors of the code are a subset of the
behaviors of the specification.
To define refinement we need to be more precise about what a program is and how it
executes. We
write $p : \gooselayer{X}$ to say $p$ is a Go program written using operations
from layer X, where X is one of NFS, Txn, or Disk.
Layer operations are always atomic transitions in a state machine. In the
NFS layer, the NFS operations behave according to the NFS state machine
described previously in \autoref{sec:soundness} and defined formally in Dafny.

The Txn layer is specified in both Coq where it is part of GoTxn's correctness
theorem and in Dafny where it appears as an assumption. The Disk transition
system is formalized in Coq as part of the GoJournal proof, and assumes reads
and writes of 4KB blocks are atomic. Each layer includes concurrent threads that
interleave layer operations, basic heap operations on pointers, slices, and
maps, and computation on primitives like integers and structs.

Refinement relates two programs in terms of their visible behavior, which we
will use to connect code written against the transaction system to the
executable code that runs on a disk. When refinement talks about the behavior of
a program, we will take this to mean the network behavior that DaisyNFS has at
the top level, from interacting with NFS clients.

\begin{definition}[Refinement]
  An implementation program $p_{c}$ refines a specification program $p_{s}$,
written $p_{c} \refines p_{s}$, if whenever there are initial states
$\sigma_{s}$ and $\sigma_{c}$ satisfying $\mathrm{init}(\sigma_{s}, \sigma_{c})$
and $p_{c}$ can execute from $\sigma_{c}$ and produce a trace of network I/O
$tr$, then $p_{s}$ can execute from $\sigma_{s}$ and produce the same trace
$tr$.  Execution might involve crashing and restarting a program (potentially
multiple times), wiping out any in-memory state after each crash.
  \label{def:refinement}
\end{definition}

The intuition behind the notation $p_{c} \refines p_{s}$ is that the set of
behaviors of $p_{c}$ (the set of traces of network I/O $tr$) is a subset of the
behaviors of $p_{s}$. Whenever we state $p_{c} \refines p_{s}$ we leave implicit
a definition of initial states $\mathrm{init}(\sigma_{s}, \sigma_{c})$, which
will generally say both states are all zeros and of the same size.

\subsection{Correctness theorem for the transaction system}
\label{sec:proof:txn}

The \cc{Txn} layer semantics serves as the interface between the Perennial and Dafny
proofs.  It specifies that transactions are atomic in the sense that code
enclosed within a transaction \cc{Begin} and \cc{Commit} happens all at once (or
does nothing, if \cc{Abort} is executed), without interleaving of steps by other
threads.

We define the correctness of the transaction system's implementation as a
\emph{program refinement}.
To set up this specification, consider a program $p : \gooselayer{Txn}$ that
uses transactions.
To run $p$, it is combined with the transaction-system implementation, producing
a program $\mathrm{link}(p, \txncode) : \gooselayer{Disk}$ that can be run on
top of a disk.
Transactions in the linked program continue to have the expected atomic
behavior, so long as transaction code in $p$ follows certain restrictions, such
as not accessing shared state outside the journal system.  We write
$\mathrm{safe}(p)$ to mean $p$ is ``safe'' in the sense that it follows these restrictions.

% At a high level of abstraction, the main difficulty is to give a specification
% for the transaction system, which we do in several steps:
%
% \begin{enumerate}
%   \item First, we define an arbitrary Go program running on top of
%         the transaction system. For reasons we will explain shortly we will use
%         $p : \gooselayer{Txn}$ for such a program. To run such a program it
%         first needs to be linked with the transaction system implementation,
%         producing a program denoted $\mathrm{link}(p, \txncode)$.
%   \item The second idea is to say what the semantics of a program
%         $p : \gooselayer{Txn}$ is. Transactions are atomic in this semantics in
%         that the whole transaction transitions at once, without interleaving
%         other threads. The program can issue reads and writes within a
%         transaction, and they follow a simple state machine.
%   \item The final idea is to define ``safe'' programs $\mathrm{safe}(p)$, those
%         that follow the restrictions of the transaction system. The
%         specification only applies to safe programs.
% \end{enumerate}

The correctness of the transaction system is summarized by the following theorem:

\begin{theorem}
  The transaction system's implementation $\txncode$ is a program refinement, meaning for
  all $p : \gooselayer{Txn}$, if $\mathrm{safe}(p)$, then
  $\mathrm{link}(p, \txncode) \refines p$. The definition of
  $init(\sigma_{s}, \sigma_{c})$ in this refinement relates an all-zero physical
  disk to an all-zero transactional disk of the same size.
  \label{thm:txn}
\end{theorem}

\autoref{thm:txn} is stated in Coq and has a fully mechanized proof in Perennial.
What it says is that if a program is safe, the program linked with the
transaction system always behaves as if its transactions were atomically
accessing a transactional disk logically maintained by the transaction system.
The definition of safety formalized in Coq requires that code within a
transaction not access any shared memory outside of the transaction layer; other
than that, transactions are permitted to issue reads, writes, and do other
computation. Safety also requires that transactions follow the preconditions of
the \cc{Read} and \cc{Write} operations, which require a discipline of accessing
each object with a fixed size. Finally, safe programs can only \cc{Abort} or
\cc{Commit} a given transaction once. The notion of safe program will be
important when linking this proof with the Dafny proofs, since the transaction
system's proof only applies to a safe caller.

In the Coq development, \autoref{thm:txn} uses Goose~\cite{chajed:goose-coqpl}
to translate the transaction system's Go implementation into a model in Coq that
Perennial supports.
