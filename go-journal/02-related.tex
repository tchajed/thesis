\section{Related work}
\label{s:related}

To the best of our knowledge, \txn is the first verified concurrent,
crash-safe journaling system. The verification of \txn builds on a
large body of previous work, as described in the rest of this
section.

\subsection{Perennial 2.0 vs Perennial 1.0}

The verification approach we take is based on a new version of our earlier
Perennial~\cite{chajed:perennial} framework, so we draw a contrast between the
two here. The new implementation is
conceptually similar in that it supports reasoning about concurrency and
crash-safety, it is implemented on top of the
Iris~\citep{jung:iris-jfp,jung:iris-1} concurrency verification system,
and it uses Goose~\cite{chajed:goose-coqpl} to enable verification of Go
programs by translating them into a model in Perennial 2.0.
However, to make verification of \txn feasible, we had to re-write many core parts of the framework.
To clarify which framework is being referenced we will write Perennial 1.0 for the
original framework and Perennial 2.0 for the new one in this section, in order
to highlight the new features Perennial 2.0 supports. The rest of the paper
generally refers only to Perennial 2.0.

%Perennial 1.0 supported verifying Go programs with a system called
%Goose~\cite{chajed:goose-coqpl} that translates Go into a model in Perennial.
%Perennial 2.0 also comes with a new version of Goose that supports the new
%verification infrastructure and extends translation to cover additional features
%in Go used in \txn.


%This figure is for the next section, but we need to put it here so the placement
%in the paper works out.
\begin{figure*}[t]
  \centering
  \small
  \begin{tabular}{lll}
    \toprule
        {\textbf{Method}} & {\textbf{Description}} & {\textbf{Spec}} \\
  \midrule
\cc{func Begin() *Op} & Start operation & \hyperlink{tgt:begin-spec}{\S\ref{s:design:lifting}} \\
\cc{func (*Op) ReadBuf(addr Addr, sz uint64) *Buf} & Read a buffer & \autoref{s:design:read-write} \\
\cc{func (*Buf) SetDirty()} & Mark a buffer as modified & \autoref{s:design:read-write} \\
\cc{func (*Op) OverWrite(a Addr, sz uint64, data []byte)} & Write without reading & \autoref{s:design:read-write} \\
\cc{func (*Op) Commit(wait bool) bool}  & Commit by appending to in-memory log. & \autoref{s:design:commit} \\
& If \cc{wait=true}, also wait until changes are on disk. & \\
\cc{func Flush() bool} & Flush in-memory log & \\
    \midrule
\cc{func (*Lockmap) Acquire(i uint64)} & Acquire \cc{i}th lock & %
                                         \autoref{s:design:crashlock} \\
\cc{func (*Lockmap) Release(i uint64)} & Release \cc{i}th lock & %
                                         \autoref{s:design:crashlock} \\
\bottomrule

  \end{tabular}

  \caption{\txn interface and API for lockmap.  Not shown are auxiliary
    interfaces for initialization; checking operation size; etc.}
  \label{fig:buftxn}
\end{figure*}

Some of Perennial 2.0's features are needed to support the \txn top-level
specification and enable verification on top of this interface. The reason this
problem is complicated is because the journal does not make operations
automatically atomic but requires the caller to correctly manage ownership, and
Perennial 1.0's refinement specifications do not give a good way to talk about
ownership. The top-level specification of \txn relies on \emph{crash
framing}~(\autoref{s:design:crashframe}) and \emph{crash-aware
locks}~(\autoref{s:design:crashlock}) to enable application proofs that reason
about ownership of durable data.

Perennial 2.0 also scales to a larger system than the mail server verified in
Perennial 1.0. One of the challenges with the larger system is that it has many
internal layers that need their own specifications, so that the proof can be
carried out modularly. Normally a separation logic or refinement-based
specification would be sufficient, but we need internal specifications that capture
the crash and concurrent behavior of each internal library. To that end
Perennial 2.0 incorporates a new specification style which adds \emph{crash
atomicity} to the logically atomic specification styles developed in earlier
work~\citep{jacobs:logatom,svendsen:hocap,pinto:tada}. Modularity in the proof
was necessary to scale verification to
all of \txn's performance optimizations and concurrency.
At the same time, \txn's specification allows
the proof of \simplenfs to mostly avoid reasoning about crashes.

%% The specification for the simple NFS server is based on closely reading RFC
%% 1813~\cite{RFC:1813}, which defines the NFSv3 API in English prose. We do not
%% attempt to formalize all allowed behaviors in the specification, but did attempt
%% to write a formal specification in Coq which would meet the prose specification.
%% \mfk{maybe say we have some confidence in our formal spec, because
%%   \simplenfs can be mounted and used by a linux client.}

%% \joe{talk about JBD2 here}

%% Lifting and disk-object ownership are
%% new techniques that would not more complicated in Perennial due to the
%% need for leases. Perennial does demonstrate a complex example that
%% requires recovery helping to prove correct; our framework does not
%% support this pattern, but we did not need it to prove \txn or the file
%% system since no helping is involved.

%% The most obvious difference to Perennial is the difference in verified artifact:
%% we prove \txn, a \gotxnLOC-line, high-performance transaction system with interesting
%% crash safety and concurrency challenges, along with a \simplenfsLOC-line NFS server using
%% it; Perennial verified a 150-line mail server. Besides simply having much more
%% code, \txn is verified in several modular layers, with four internal APIs, and
%% then we use the specification to verify an application. Perennial did not
%% explain or demonstrate a modular verification story; our contribution of
%% logically atomic crash specifications allows us to scale verification to this
%% larger system by specifying internal APIs, which are more complex than the
%% client-visible one.

%% Perennial did not include explicit crash conditions, instead carrying out all
%% crash reasoning using an invariant. This works for small examples but is
%% inconvenient for modular verification. We instead build on a framework that uses
%% Iris but augments Hoare logic specifications with a crash condition, in the
%% style of FSCQ's Crash Hoare Logic, but extended to support concurrency.

% \subsection{Related verification efforts}

\subsection{Related verification frameworks}

\paragraph{Crash-safe systems.}

% Perennial 2.0's atomic crash specifications enable \txn to formalize the crash behavior
% of a layer in a lightweight fashion---that is, promising that a layer does not
% expose any unexpected intermediate states after a crash.
Any crash-safe system
must reason about the possible states after a crash, and several prior works
have formalized this in different ways for \emph{sequential} crash-safe systems.
FSCQ~\cite{chen:fscq,chen:dfscq} uses Crash Hoare Logic (CHL) to specify crash
behavior through a crash condition, which describes the state of a system if a
crash happens during execution of a function. Alternatively, a number of systems
verify crash safety using refinement
reasoning~\cite{sigurbjarnarson:yggdrasil,ernst:crash-refinement-asms,chajed:argosy,hance:veribetrkv},
but none support the combination of concurrency and crash-safety.

% However, refinement-based proofs can require additional layers for proof purposes
% that do not correspond to modules in the original code.

% However, refinement based proofs can be heavy-weight because they require
% formalizing the entire set of operations that can be performed at every layer of
% a refinement proof (including logically orthogonal operations like allocating
% memory, accessing data structures, and calling other libraries).
% \ralf{I don't understand the last sentence. It seems to be specifically about CSPEC, not refinement proofs in general?}

Although they are not concurrent, some of these systems address other
aspects of performant storage systems that are not found in \txn.
DFSCQ~\cite{chen:dfscq} verifies a high-performance file system built
on top of a logging system with asynchronous disks and log-bypass
writes, which are challenging optimizations that \txn does not
support. VeriBetrKV~\cite{hance:veribetrkv} verifies a key-value store
based on B\textsuperscript{$\epsilon$} trees, a data structure that also underlies BetrFS~\cite{jannen:betrfs}. \txn
and \simplenfs use simple data structures;
the challenge lies in accounting for concurrent accesses.
%where the challenge is concurrent access.
% concurrent access to these structures.

% The proof technique uses refinement between layers
% in a way that is lighter-weight and more flexible than in CSPEC,a and
% additionally uses the crash guarantees of one layer to prove the crash
% guarantees of a higher layer. VeriBetrFS is implemented in Dafny, which has
% tight integration with Hoare logic; this makes it easier to use but also harder
% to extend, particularly with concurrency. In Coq the program logic is not
% built-in, which gives the flexibility to implement a new logic (as FSCQ did) or
% to extend an existing one (as we do on top of the Iris program logic).

\paragraph{Concurrent systems.}

In addition to specifying behavior at intermediate crash points, Perennial 2.0's
specifications describe the atomic commit points of concurrent operations. A
range of verification techniques have been used to address this kind of
challenge in concurrent systems. AtomFS~\cite{zou:atomfs} uses a framework
called CRL-H (concurrent relational logic with helpers) to verify a concurrent
in-memory file system implemented in C. Refinement-based systems such as
CSPEC~\cite{chajed:cspec}, Armada~\cite{lorch:armada}, and Concurrent
CertiKOS~\cite{gu:certikos-ccal} typically prove that a function implements an
atomic operation at a more abstract layer.
However, in \txn, many internal APIs provide operations that are only atomic if
the caller owns some data. This kind of conditional atomicity is easy to express
in Perennial 2.0 using separation logic, but hard to express
as a precondition in a transition system.
% Additionally, as with using refinement for crash-safety reasoning, refinement-based approaches often introduce extra layers for proof purposes. On the other hand, proofs of refinement between
% layers in an SMT-based system like Armada are automated, while proofs are
% interactive in Perennial 2.0.

% Armada~\cite{lorch:armada} also verifies C code but uses a different approach
% based on several layers of refinement between levels, which are progressively
% more abstract versions of the code. Neither of these frameworks
% supports crash-safety guarantees, and neither supports modular verification of a
% lower-level layer independently of upper layers that use it.


\paragraph{Concurrent, crash-safe reasoning.}

Program logics other than Perennial
have been developed for formal reasoning about concurrent, crash-safe systems.
Fault-Tolerant Concurrent Separation Logic (FTCSL)~\cite{ntzik:faults} extends
the Views~\cite{dinsdale:views} concurrency logic to incorporate crash-safety.
POG~\cite{raad:pog} is a program logic for reasoning about the interaction of
x86-TSO weak-memory consistency and non-volatile memory.
Neither logic has a mechanism for modular proofs of layers,
which we found essential to scale verification to a system of \txn's
complexity. Both are restricted to pen-and-paper proofs, whereas both Perennial
1.0 and 2.0 have machine-checked proofs.

A specification called the Push/Pull model of
transactions~\cite{koskinen:pushpull} is similar to the \emph{lifting} technique
in the journal system's specification~(\autoref{s:design:lifting}) --- the core
problem addressed is that a journal operation atomically modifies a small number
of objects, but other objects can change between the start of the operation and when
it commits. The Push/Pull model also discusses reasoning on top of the
specification, using Lipton's reduction~\cite{lipton:movers} rather than
separation-logic ownership to handle concurrency. However that work is about
on-paper specifications and proofs, while we also prove an implementation meets
our specification and proved \simplenfs on top.
