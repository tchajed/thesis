To the best of our knowledge, \txn is the first verified concurrent,
crash-safe journaling system. The verification of \txn builds on a
large body of previous work, as described in the rest of this
section.

\subsection{Related verification frameworks}

\paragraph{Crash-safe systems.}

% Perennial 2.0's atomic crash specifications enable \txn to formalize the crash behavior
% of a layer in a lightweight fashion---that is, promising that a layer does not
% expose any unexpected intermediate states after a crash.
Any crash-safe system
must reason about the possible states after a crash, and several prior works
have formalized this in different ways for \emph{sequential} crash-safe systems.
FSCQ~\cite{chen:fscq,chen:dfscq} uses Crash Hoare Logic (CHL) to specify crash
behavior through a crash condition, which describes the state of a system if a
crash happens during execution of a function. Alternatively, a number of systems
verify crash safety using refinement
reasoning~\cite{sigurbjarnarson:yggdrasil,ernst:crash-refinement-asms,chajed:argosy,hance:veribetrkv},
but none support the combination of concurrency and crash-safety.

% However, refinement-based proofs can require additional layers for proof purposes
% that do not correspond to modules in the original code.

% However, refinement based proofs can be heavy-weight because they require
% formalizing the entire set of operations that can be performed at every layer of
% a refinement proof (including logically orthogonal operations like allocating
% memory, accessing data structures, and calling other libraries).
% \ralf{I don't understand the last sentence. It seems to be specifically about CSPEC, not refinement proofs in general?}

Although they are not concurrent, some of these systems address other
aspects of performant storage systems that are not found in \txn.
DFSCQ~\cite{chen:dfscq} verifies a high-performance file system built
on top of a logging system with asynchronous disks and log-bypass
writes, which are challenging optimizations that \txn does not
support. VeriBetrKV~\cite{hance:veribetrkv} verifies a key-value store
based on B\textsuperscript{$\epsilon$} trees, a data structure that also underlies BetrFS~\cite{jannen:betrfs}. \txn
and \simplenfs use simple data structures;
the challenge lies in accounting for concurrent accesses.
%where the challenge is concurrent access.
% concurrent access to these structures.

% The proof technique uses refinement between layers
% in a way that is lighter-weight and more flexible than in CSPEC,a and
% additionally uses the crash guarantees of one layer to prove the crash
% guarantees of a higher layer. VeriBetrFS is implemented in Dafny, which has
% tight integration with Hoare logic; this makes it easier to use but also harder
% to extend, particularly with concurrency. In Coq the program logic is not
% built-in, which gives the flexibility to implement a new logic (as FSCQ did) or
% to extend an existing one (as we do on top of the Iris program logic).

\paragraph{Concurrent systems.}

In addition to specifying behavior at intermediate crash points, Perennial 2.0's
specifications describe the atomic commit points of concurrent operations. A
range of verification techniques have been used to address this kind of
challenge in concurrent systems. AtomFS~\cite{zou:atomfs} uses a framework
called CRL-H (concurrent relational logic with helpers) to verify a concurrent
in-memory file system implemented in C. Refinement-based systems such as
CSPEC~\cite{chajed:cspec}, Armada~\cite{lorch:armada}, and Concurrent
CertiKOS~\cite{gu:certikos-ccal} typically prove that a function implements an
atomic operation at a more abstract layer.
However, in \txn, many internal APIs provide operations that are only atomic if
the caller owns some data. This kind of conditional atomicity is easy to express
in Perennial 2.0 using separation logic, but hard to express
as a precondition in a transition system.
% Additionally, as with using refinement for crash-safety reasoning, refinement-based approaches often introduce extra layers for proof purposes. On the other hand, proofs of refinement between
% layers in an SMT-based system like Armada are automated, while proofs are
% interactive in Perennial 2.0.

% Armada~\cite{lorch:armada} also verifies C code but uses a different approach
% based on several layers of refinement between levels, which are progressively
% more abstract versions of the code. Neither of these frameworks
% supports crash-safety guarantees, and neither supports modular verification of a
% lower-level layer independently of upper layers that use it.


\paragraph{Concurrent, crash-safe reasoning.}

Program logics other than Perennial
have been developed for formal reasoning about concurrent, crash-safe systems.
Fault-Tolerant Concurrent Separation Logic (FTCSL)~\cite{ntzik:faults} extends
the Views~\cite{dinsdale:views} concurrency logic to incorporate crash-safety.
POG~\cite{raad:pog} is a program logic for reasoning about the interaction of
x86-TSO weak-memory consistency and non-volatile memory.
Neither logic has a mechanism for modular proofs of layers,
which we found essential to scale verification to a system of \txn's
complexity. Both are restricted to pen-and-paper proofs, whereas both Perennial
1.0 and 2.0 have machine-checked proofs.

A specification called the Push/Pull model of
transactions~\cite{koskinen:pushpull} is similar to the \emph{lifting} technique
in the journal system's specification~(\cref{s:design:lifting}) --- the core
problem addressed is that a journal operation atomically modifies a small number
of objects, but other objects can change between the start of the operation and when
it commits. The Push/Pull model also discusses reasoning on top of the
specification, using Lipton's reduction~\cite{lipton:movers} rather than
separation-logic ownership to handle concurrency. However that work is about
on-paper specifications and proofs, while we also prove an implementation meets
our specification and proved \simplenfs on top.
