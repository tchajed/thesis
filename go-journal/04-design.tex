%% indexing disk generations

% And using its specs reads a little clunky to me -JDT
%\section{Specifying \txn and using its specs}

\section{Specifying GoJournal}
\label{s:design}

%% This section walks through the \txn specification as well as how an application
%% proof uses it to prove linearizability.  We use the simple NFS server and its
%% Write operation as an example to make things more concrete.

%% The idea for code is that the transaction system makes linearizability easy by
%% wrapping everything up in a transaction. The specification realizes this for the
%% proof. \tej{more to say here for context}

%% The high-level flow for the Write transaction is seen in \cc{NFS3_WRITE}:
%% the code starts a transaction with \cc{Begin}, then runs
%% \cc{NFS3_WRITE_locked} within a critical section around the file lock.
%% \cc{NFS3_WRITE_locked} consists of \cc{NFS3_WRITE_wp} --- which
%% prepares the \cc{op} with the buffered writes needed to implement the RPC ---
%% followed by a call to \cc{Commit(true)} to finally make the transaction durable.

\tej{Bunch of work in this section. First explain why this layer is needed in
GoTxn, and second less emphasis on a caller since the spec is only used once
to prove a generic transaction correct.}

\tej{some of the GoJournal paper's motivation (about the difficulty of capturing
the crash atomicity of a journal) do apply to this section, and need to be
introduced locally since the chapter is otherwise about a transaction system}

The goal of \txn's specification is to support convenient reasoning about atomic
operations, like the NFS \scc{write} implementation in \autoref{fig:nfswrite} and \autoref{fig:write}.
In this section we walk through how the specification
guarantees atomicity for the caller without forcing the caller to do
much application-specific reasoning about concurrency or
crashes.

The key to this specification is tracking resources, like the disk blocks making up a
file, as they flow through the steps of the proof. We start by reviewing how
separation logics like Perennial represent these resources, and how
specifications in the logic track logical \emph{ownership} of
resources~(\autoref{s:design:rep}). The specification for \txn introduces
resources that distinguish between a journal operation's local view of an object and
the durable, on-disk representation; obtaining either resource
requires the caller to use correct synchronization, as required by the journal's
implementation. \emph{Lifting} provides a
way to translate
a locked object from its on-disk view to a local view within the operation~(\autoref{s:design:lifting}).
While preparing a journal operation, reads and writes modify the local
view~(\autoref{s:design:read-write}). Finally, committing an operation writes
its updates to disk, so the specification asserts that the local
view becomes a view over durable state.

To take full advantage of the durable and operation-local views of
journal objects, the proof of \scc{Write} uses two new techniques introduced by
Perennial 2.0: crash-aware locking~(\autoref{s:design:crashlock}) and crash
framing~(\autoref{s:design:crashframe}). With these techniques, the proof of
\cc{NFS3_WRITE_op} uses entirely sequential reasoning for preparing the
journal operation, even though concurrent operations might write to disk and its
disk writes are buffered rather than synchronous.
Finally, \autoref{s:design:summary} summarizes how the proof
techniques combine to prove correctness and crash-safety for the NFS \scc{write}
example.

%% This property is sometimes called linearizability,
%% and in this paper we will informally use the term ``linearization point'' to
%% refer to a point after which the operation has logically occurred, meaning other
%% threads will observe its effect.

\subsection{File representation}
\label{s:design:rep}

First, in both designing the code and writing the proof, the NFS server must
establish a disk layout to arrange its data in terms of disk objects. The disk
layout is expressed using a separation-logic \emph{representation invariant}, a
predicate which connects the logical (specification-level) contents of files to the objects (inodes and
blocks) that encode those files.

%  From a
% user's perspective looking at the file system, its state is a collection of
% files named by inode number, where a file is a list of bytes. Internally, in the
% file system, a file with inode number $i$ is stored as a metadata object with
% the file's size and the address of its (single) data block. The proof maintains
% a representation invariant that connects the abstract state of a file seen by
% users to the physical representation in terms of metadata and data.

Representation invariants over the state of the journal use a
``points-to predicate'' $a \mapsto o$, which serves two purposes: it asserts
that the address $a$ (of type \cc{Addr}) contains an object $o$ (which is
represented by the \cc{*Buf} type in the API), and it represents exclusive
\emph{ownership} over the address~$a$. When a thread has $a \mapsto o$ in its
precondition, ownership allows the proof to assume that the value at address $a$
does not change until the thread gives up ownership, and that it will not be
read by other threads.  Locks help threads transfer ownership so a thread only
retains exclusive ownership during a critical section.

The \simplenfs proof connects each file to its representation with the following
representation invariant:
%
\begin{align*}
  &\cc{file_rep}(i, \mathit{data}) \triangleq \exists \mathit{meta}, \exists \mathit{blk}, \\
  &\quad i \mapsto \mathit{meta} \sep \mathit{meta}.\cc{blkno} \mapsto blk \land \phantom{} \\
  &\quad \mathit{meta}.\cc{size} = \cc{length}(\mathit{data}) \land \cc{prefix}(\mathit{data}, \mathit{blk})
\end{align*}

Informally the representation invariant says the file $i$ with logical contents $\mathit{data}$ is represented by some
metadata $\mathit{meta}$ stored at the inode number $i$ and a data block at
$\mathit{meta}.\cc{blkno}$. It then says the file's bytes are a
$\mathit{meta}.\cc{size}$-length prefix of the data block.

This definition uses the separating conjunction $P \sep Q$ (pronounced ``$P$ and
separately $Q$''), which says that two predicates hold over disjoint state.
%\ralf{It mixes separating and regular conjunction... wouldn't it be easier to use separation conjunction throughout?}
For example, this asserts the inode and its data block are stored
separately. To initialize the system the caller must prove that the
\cc{file_rep} predicates hold separately for each file, that is,
$\cc{file_rep}(1, \mathit{data}_1) \sep \cc{file_rep}(2, \mathit{data}_2) \sep \cdots$. Here the
separating conjunction asserts files are represented disjointly, so that when a
thread modifies one file it is guaranteed not to affect data in other files.

\subsection{Lifting}
\label{s:design:lifting}

\newcommand{\bufobjDurable}{\cc{durable_pred}\xspace}

The key idea of \txn's specification is to consider two view of the disk: a
conceptual in-memory view that a buffered journal operation observes, as well as
an on-disk view that reflects what would be on disk after a crash. Parts of both views are constantly changing as
other threads commit operations concurrently, so we use separation logic to
define a local view that contains only objects locked by and involved in a
journal operation. Because the journal operation logically owns these objects, the caller
can use sequential reasoning---disk objects have the same value throughout---and can commit all of the objects written in the operation at
the end without fear of interfering with concurrent journal operations. The
specification makes this informal reasoning concrete using \emph{lifting}, which
we use to refer to this strategy of transferring ownership to and from the
on-going operation.

To do anything with the journal, a thread must first \cc{Begin} an atomic operation:
\hypertarget{tgt:begin-spec}{}
%
\begin{align*}
  \hoareV{\TRUE}{\cc{Begin}()}{\Ret{op}
    \cc{is_op}(\mathit{op}) \sep
    \bufobjDurable(\mathit{op}, \TRUE)}
   %\tagH{BeginSpec}
\end{align*}

The specification above is a Hoare triple for the \cc{Begin()} function. It says
that executing \cc{Begin()} starting with its precondition (in this case $\TRUE$) will run
without errors and if it terminates it will return $\mathit{op}$ along with the
postcondition, namely $\cc{is_op}(\mathit{op}) \sep \bufobjDurable(\mathit{op}, \TRUE)$.
The \cc{is_op} part of the post-condition simply says that $\mathit{op}$ is a
valid \cc{*Op} object. The $\bufobjDurable(\mathit{op}, \TRUE)$ clause is what tracks the
on-disk data ``underneath'' a journal operation, which would be left behind if the
operation aborted; since the operation starts out with an empty local view,
it starts out with no on-disk footprint, written as $\TRUE$.

%Before we can describe lifting, we need a way to talk about the logical state of
% the journal and the local view from within a transaction.

The different views of a journal operation are tracked using \emph{ghost state} in Iris.  Ghost state is separate from
the physical state of the program---the contents of memory and disk---and is
only manipulated by the proof. The journaling system's proof introduces ghost
state for durable state of the system, including an $a \mapsto_{d} o$ predicate
for ownership over individual objects. Note that an object is expressed through
ghost state because the block holding the object might be located in the on-disk
log or in the data region, and ownership of an object says nothing about other
objects in the same disk block.

The proof also introduces a similar $a \mapsto_{\mathit{op}} o$ predicate for the local
view of operation \cc{op}, and it is this ownership that is needed for reads and
writes. A caller obtains these predicates with a logical operation we call
\emph{lifting} that converts ownership of $a \mapsto_{d} o$ into $a \mapsto_{\mathit{op}} o$, granting the
ability to read and write.

\tej{lifting between disk/txn is still important, but lifting of predicates is
irrelevant to GoTxn}

To make it easier to work with lifting, the specification allows lifting an
entire \emph{predicate} $P$ and transforms all of its points-to facts
simultaneously, which we denote this paper denotes by switching subscripts. For
example, we re-use
the definition $\cc{file_rep}$ from \autoref{s:design:rep} for both a file laid
out on disk and a file as owned by a journal operation, which we denote with
$\cc{file_rep}_{d}$ and $\cc{file_rep}_{\mathit{op}}$ respectively. The specification
for lifting a generic predicate $P$ is:
%
\begin{align*}
  \hoareV{P_d \sep \bufobjDurable(\mathit{op}, Q_d)}{\SKIP}{P_{\mathit{op}} \sep \bufobjDurable(\mathit{op}, P_d \sep Q_d)}
\end{align*}

Since lifting is purely logical (it only modifies ghost state), we
write it as a Hoare triple for a no-op, much like how Dafny and \fstar lemmas
are simply methods with pre- and post-conditions but no code~\cite[\S 12.2.3]{dafny-refman}.%
\footnote{In case the reader is already familiar with Iris, these Hoare triples represent
what is usually called a ``view shift'' in Iris.}
The outcome of lifting is to expand the memory covered by the journal operation to
incorporate $P_{d}$. Observe that \bufobjDurable is expanded to ``snapshot''
$P_{d}$, which tracks that if the operation were to abort or crash, the
durable $P_d$ that we started with would still hold.  The on-disk values
do not change over the course of a buffered journal operation (as expected, since these are
in-memory writes). The key part of the postcondition, however, is $P_{op}$: the
$a \mapsto_{op} o$ predicates within $P_{op}$ (e.g., the
$i \mapsto_{\mathit{op}} \mathit{meta}$ within $\cc{file_rep}_{\mathit{op}}(i, \mathit{data})$)
give the caller
the right to read and write objects from within the operation, as we will see
in~\autoref{s:design:read-write}.

% The ghost state involved in defining the $a \mapsto_{\mathit{op}} o$ predicate
% is somewhat subtle in order to implement lifting: the proof must track that
% ownership of this predicate guarantees that the on-disk value of address $a$
% remains $o$.

\subsection{Reads and writes}
\label{s:design:read-write}

The specification for \cc{OverWrite} describes the effect of writing to the
local memory of a buffered journal operation:
%
\begin{align*}
  \hoareV{\cc{is_op}(\mathit{op}) \sep a \mapsto_{\mathit{op}} o \sep \cc{buf_obj}(buf, o')}%
        {\mathit{op}.\cc{OverWrite}(a, buf)}%
        {\cc{is_op}(\mathit{op}) \sep a \mapsto_{\mathit{op}} o'}
  %\tagH{OverWriteSpec}
\end{align*}

The precondition includes $\cc{buf_obj}(buf, o')$ to say that the in-memory
buffer $buf$ encodes the object to be written $o'$.
The \cc{is_op} predicate is both
required and returned by the specification, which reflects the fact that
\cc{OverWrite} operates on the in-memory state covered by
this predicate.

The specification for \cc{ReadBuf} is more subtle.  \cc{ReadBuf}
returns a buffer that the caller is allowed to modify in-place, which
has the side-effect of updating the in-memory state of the ongoing journal operation, which
will in turn be committed by \cc{Commit}.  \autoref{fig:write} shows
an example, where lines 18--20 modify a read buffer in-place.  The specification
captures this behavior as follows:
%
\begin{align*}
  \hoareV{\cc{is_op}(\mathit{op}) \sep a \mapsto_{\mathit{op}} o}%
        {op.\cc{ReadBuf}(a)}%
        {\Ret{buf}
  \begin{aligned}
  &\cc{buf_obj}(\mathit{buf}, o) \sep \phantom{} \\
  &\quad( \forall o', \cc{buf_obj}(\mathit{buf}, o') \wand \\
  &\quad\quad \cc{is_op}(\mathit{op}) \sep a \mapsto_{\mathit{op}} o' )
    \end{aligned}}
    %\tagH{ReadBufSpec}
\end{align*}

This states that, when \cc{ReadBuf} finishes, it returns a buffer $\mathit{buf}$
and two resources: $\cc{buf_obj}(\mathit{buf}, o)$ says the buffer has the old
object $o$, while the second is a separating implication or \emph{wand} $\wand$.
The wand says that if
the caller modifies the buffer to produce $\cc{buf_obj}(\mathit{buf}, o')$ for
some other data $o'$ (or leaves it unchanged, picking $o' = o$), it can get back
the $\cc{is_op}(\mathit{op})$ predicate, along with a
$a \mapsto_{\mathit{op}} o'$ fact indicating that $a$ has been modified in-place
to the new data $o'$.\footnote{To simplify the presentation, we have omitted
the obligation that forces the caller to call $\mathit{buf}.\cc{SetDirty}()$
before getting back \cc{is_op}.} The wand is just another resource that the
caller can invoke at the right time in the proof (e.g., after the call to
\cc{SetDirty} in \autoref{fig:write} on line 21).

\subsection{Crash-aware locking}
\label{s:design:crashlock}

As seen in \autoref{fig:nfswrite}, the NFS server acquires a per-file lock
(within the lockmap) to prevent concurrent access to the same disk object.
Each lock
logically protects both the file metadata stored in its inode and the data block pointed
to by the inode. The usual specification for a lock
in concurrent separation logic says
that it protects some lock invariant, guaranteeing that this
invariant holds upon acquiring the lock and conversely obliging the caller to
prove the lock invariant to release.
This invariant may claim ownership of resources which are then owned by clients during their critical section.
The file $i$'s lock in \simplenfs protects
roughly $\cc{file_rep}_{d}(i, data)$, where we write $d$ to indicate the file is
laid out on disk; we make the invariant more precise later when we connect it to
crash safety.

This lock specification, however, is insufficient to prove that the \simplenfs server maintains all relevant invariants when the system crashes.
The specification makes no guarantees about the protected data during
a critical section---%
however, a crash while the lock is held exposes any durable data that
was protected by the lock. The lock specification fails to express that the lock
holder should keep the durable data in a state that can be recovered from after a crash.
% Thus we cannot use the lock specification to protect
% durable ownership: that ownership would be lost on crash, even though in reality the
% code will use the journaling system to safely modify disk only atomically.

To solve this problem, Perennial 2.0 contributes a new
specification for locks called \emph{crash-aware lock specifications}
that is useful for protecting durable data like $\cc{file_rep}_{d}$. We proved
this specification both for ordinary locks (\cc{*sync.Mutex} in Go) and
for the stripes in the lockmap, but here we present just the lockmap version.
With this specification, the
proof associates not just a lock invariant but also a \emph{crash obligation} $I_c(\cc{i})$ to each file. Like the ordinary
lock specification, acquiring the lock gives the caller access to the lock
invariant $I(\cc{i})$, but unlike that spec, this specification also obliges the
caller to prove the crash obligation $I_c(\cc{i})$ at every intermediate step. The proof
enforces this using crash specifications:
$\hoareC{P}{e}{Q}{Q_{c}}$ is like a Hoare triple but it has an extra predicate
$Q_{c}$, the crash condition, describing what holds if the system crashes during $e$'s execution.
When the caller wants to prove something about code that acquires a lock using
the crash-aware specification, it must do so with $I_c(\cc{i})$ in its crash
condition for the critical section:
\tej{something messier is needed to reason about the lock/release happening in
the 2PL code; the underlying spec I believe is that acquiring a crash lock
gives a crash borrow, and then the 2PL code has to open/close it for each read
or write operation; releasing the lock is easy in that case.}
%
\begin{align*}
&\hoareC{P \sep I(\cc{i})}{\cc{f()}}{Q \sep I(\cc{i})}{I_c(\cc{i})} \\
&\vdash \hoare{P}{\cc{Acquire}(\cc{i});\, \cc{f()};\, \cc{Release}(\cc{i})}{Q}
%\tagH{LockSpec}
\end{align*}

% Observe that to prove a Hoare triple about a critical section, the caller must
% prove a Hoare quadruple.
In exchange for the extra work of having to prove a crash specification, the crash-aware
lock spec guarantees
that the lock's crash obligation holds at crash time, ready to be
used by new threads spawned following the crash.
% In practice for the
% journaling system and its callers, crash framing eliminates much of the proof
% burden for the $I_c$ obligation, as described in
% \autoref{s:design:crashframe}; intuitively this is because in the
% critical section, the code does not write to disk until the end when it
% commits.

One final subtlety in the specification is that Perennial distinguishes between
the disk while running $d_{k}$ and the new disk following a crash $d_{k+1}$,
where $k$ is a so-called \emph{generation number}. This creates a distinction
between the invariant protected by the lock (in generation $k$) and the crash
obligation (in the next generation):
\begin{align*}
  I(i) &\triangleq \exists \mathit{data}, \cc{file_rep}_{d_{k}}(i, \mathit{data}) \\
  I_c(i) &\triangleq \exists \mathit{data}, \cc{file_rep}_{d_{k+1}}(i, \mathit{data})
\end{align*}

It is important that on crash the developer show $\cc{file_rep}$ holds in the
post-crash generation $d_{k+1}$, because any ephemeral resources in the current
generation do not survive to the next. Any in-memory state the system requires
has to be reconstructed from only the durable state.

% Not shown in these
% simplified versions of $I(i)$ and $I_c(i)$ are the connections between
% $\mathit{data}$ and the state of the inode that the top-level specification
% describes (e.g., \autoref{fig:nfswritespec}).


\subsection{Crash framing}
\label{s:design:crashframe}

As we have seen, acquiring a crash-aware lock imposes that the crash obligation holds at
every step until the crash lock is released.  For example, the developer must
show that the crash obligation $I_c(i)$
holds at every step of \cc{NFS3_WRITE_locked}.  However, much of the
code for \cc{NFS3_WRITE_locked} resides in \cc{NFS3_WRITE_op},
which modifies only in-memory state.  This presents an opportunity to
simplify the proof: because no durable state is modified, the developer
should not need to think about crashes at each individual step.

Perennial 2.0 formalizes this using the \emph{crash framing} technique, expressed in the
following rule:
%
\begin{align*}
&\hoare{P}{\cc{f()}}{Q} \\
&\vdash \hoareC{I_c\sep P}{\cc{f()}}{I_c\sep Q}{I_c}
\end{align*}

Informally, this rule says that if we currently own the crash condition $I_c$, we can temporarily ``give up'' access to that ownership when proving \cc{f()}.
In exchange, the crash condition is removed from our proof obligation: it is sufficient to prove a regular crash-free Hoare triple for \cc{f()}.
$I_c$ is not available for the proof of \cc{f()} (this is the ``giving up'' aspect of crash framing),
but the proof can continue to use $I_{c}$ after the call to \cc{f()} returns.

The proof of \cc{NFS3_WRITE} gets access to $I(\cc{i})$ by acquiring the
\cc{i}th lock, lifts the $\cc{file_rep}_{d_k}$ predicate into its buffered operation,
and then immediately uses the crash framing rule to give up access to
$\bufobjDurable(\mathit{op}, \cc{file_rep}_{d_k})$ and prove the crash condition for the
duration of \cc{NFS3_WRITE_op} (which only manipulates the in-memory
$\cc{file_rep}_{op}$). The crash framing rule gives back the
$\bufobjDurable$ predicate at the end of the operation,
which is required to reason about commit.

\subsection{Commit}
\label{s:design:commit}

The remainder of the proof after preparing $\cc{file_rep}_{op}$ with the new
data is to reason about committing the operation with the new file. The code
commits this operation using the following specification for \cc{Commit}:
%
\begin{align*}
  \hoareCV{Q_{\mathit{op}} \sep \cc{is_op}(\mathit{op}) \sep \bufobjDurable(\mathit{op}, P_d)}%
  {\mathit{op}.\cc{Commit}(\mathrm{true})}%
  {\Ret{\mathit{ok}} \mathrm{if~} \mathit{ok} \mathrm{~then~} Q_d \mathrm{~else~} P_d}%
  {P_d \lor Q_d}
  %\tagH{CommitSpec}
\end{align*}

\tej{should immediately explain how this is used to prove 2PL Commit in
refinement proof}
This specification nicely captures how \cc{Commit} works: if we started with data
$P_d$ on disk, then modified it to $Q_{op}$ in memory, then if \cc{Commit} succeeds
the new data $Q_d$ is on disk. If \cc{Commit} fails (which happens if the
journal operation is too large to fit on disk) then the data reverts back to $P_d$. On
crash either of these could happen, depending on when the crash
occurs.\footnote{For $\mathit{op}.\cc{Commit}(\mathrm{false})$, which
does not flush to disk right away, \txn provides a lower-level spec that
allows expressing the more complex resulting crash condition.}

The caller will sometimes start an operation and then abort it, say due to
encountering an error. The API has no method for this because aborting is a purely
logical operation that restores ownership of the on-disk objects:
%
\begin{align*}
  \hoare{\bufobjDurable(\mathit{op}, Q_{d})}{\SKIP}{Q_{d}}
\end{align*}
%
The Commit proof internally executes the same logical operation when the commit
fails in order to return the original durable data.

\subsection{Summary}
\label{s:design:summary}

\tej{Summary was nice before but now need to figure out how to summarize the
  GoJournal spec or combine it with the 2PL proof or something in between. It
  would be nice to explain something about the GoJournal spec for sure, if only
  to make the explanation a bit more modular.}

The combination of above features mean the developer is mostly left with
sequential crash-free reasoning about how each operation (for example, each NFS3 RPC
implementation) transitions from the representation invariant in one state to
another, following the transition system of the specification. We
illustrate that proof flow using the \cc{NFS3_WRITE} call in
\autoref{fig:nfswrite} as an example.

%First, the function starts a transaction, creating an empty local view
%$\bufobjDurable(txn, emp)$. We can mostly ignore $\cc{is_op}(txn)$, which is
%carried through the proof unchanged until commit. Then the code acquires a lock
%on \cc{i} to obtain $\cc{file_rep}_{d_{k}}(i, data)$ while proving
%$\cc{file_rep}_{d_{k+1}}(i, data)$ on crash. Immediately the proof lifts the
%entire file representation into memory, obtaining two things:
%$\cc{file_rep}_{op}(i, data)$ and separately
%$\bufobjDurable(txn, \cc{file_rep}_{d_{k}}(i, data))$. The latter proves the
%crash obligation from acquiring the lock and is only needed to commit, so the
%proof frames it out for the duration of \cc{NFS3_WRITE_txn}. The remaining
%reasoning is sequential until we return to \cc{NFS3_WRITE_locked} to call
%\cc{txn.Commit(true)}. \tej{we could summarize this entire paragraph rapidly}

% First, the function starts a transaction and acquires a lock. The proof requires
% some purely mechanical work to take the lock invariant
% $\cc{file_rep}_{d_{k}}(i, data)$, lift it into the transaction, and then
% immediately frame the resulting
% $\bufobjDurable(txn, \cc{file_rep}_{d_{k}}(i, data))$ snapshot until commit
% time, where it will remember what happens if \cc{txn.Commit} fails or the system
% crashes in the middle.

First, the function starts a journal operation and acquires a lock on \cc{i}. Then the proof
requires some purely mechanical work to lift the lock invariant
(\autoref{s:design:lifting}) and frame the crash obligation
(\autoref{s:design:crashframe}). Next, the developer proves the correctness of
the sequential code. This proof does involve the bulk of the application code,
but it requires neither worrying about concurrency (since reads and writes
operate on the exclusive ownership of $a \mapsto_{\mathit{op}} o$) nor about crash safety
(since crash framing has dismissed any crash obligations while reasoning
about the in-memory operations on the \cc{*Op}).

The sequential code must prove that the reads and writes with \cc{ReadBuf},
\cc{SetDirty}, and \cc{OverWrite} transform $\cc{file_rep}_{\mathit{op}}(i, data)$ to
produce $\cc{file_rep}_{\mathit{op}}(i, \mathit{data}')$, where $data'$ is the correct state of
the file as described by the transition of the formalized NFS state machine for a write. The new
file representation with contents $data'$ is the $Q_{\mathit{op}}$ in the precondition
to \cc{Commit}'s specification, while $P_{d}$ is the old file with contents
$\mathit{data}$ on disk (snapshotted while lifting).

If the system doesn't crash and \cc{Commit} returns true, then the operation
succeeds, producing a new file representation
$\cc{file_rep}_{d_{k}}(i, \mathit{data'})$. If the operation fails (say due to
not fitting in the log), then \cc{Commit} returns the old representation
invariant with contents $\mathit{data}$. On crash, either of these two is
possible, but not some inconsistent combination of the two, guaranteeing crash atomicity.

The proof for \cc{NFS3_WRITE} wraps up by releasing the lock. Whether or not
\cc{Commit} succeeds, we have a file with some contents:
$\exists \mathit{data}, \cc{file_rep}_{d_{k}}(i, \mathit{data})$; this is
exactly the lock invariant $I(i)$ required to release the lock.

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "paper.tex"
%%% End:
