This thesis describes an approach to verify software with a combination of
concurrency in the implementation and crash-safety guarantees, applied to the
DaisyNFS file system. It spans from foundations for verifying this software in
general through the design and proof of the file system itself. The foundations
include Perennial, a program logic for crashes and concurrency, and Goose, an
approach for reasoning about Go code. DaisyNFS is designed around a verified
transaction system called GoTxn, which makes it feasible to scale verification
by enabling sequential reasoning for transactions on top.

\section{Discussion}

\paragraph{Memory safety.}
A surprisingly difficult aspect of the proof was addressing memory safety
considerations. These show up in two ways: describing ownership at interface
boundaries and reasoning about read-only sharing.

DaisyNFS has two important interface boundaries, one between GooseLang and the
disk, and another to describe the GoTxn interface. Both APIs involve data in the
form of byte slices. The challenging aspect of using bytes in a method is
specifying how \emph{ownership} transfers. For example, the \cc{DiskWrite(a, v)}
operation passes a buffer \cc{v} to the disk. It could be that ownership of
\cc{v} needs to be transferred to the disk, since it uses the buffer later, or
that \cc{v} should be read-only for the duration of the call and ownership is
returned to the caller, or that if \cc{v} is permanently read-only the disk and
caller can share the buffer.

Expressing ownership as a logical idea in the logic is relatively easy using
separation logic, but the semantics of \cc{DiskWrite(a, v)} has to be
axiomatized. In order to simplify expressing the ownership transfer, the
GooseLang \cc{DiskRead} returns a freshly allocated buffer, but it would have
been better for performance if the caller supplied a buffer that the
\cc{DiskRead} wrote to (as in the usual \cc{read} system call). Similarly, the
GoTxn interface to Dafny makes additional copies to simplify ownership
reasoning, especially in the program refinement proof. A better solution would
have been to develop a specification style for expressing ownership in the
semantics of the operations themselves, along with associated reasoning
principles.

Another challenge in the internals of GoTxn was reasoning about read-only
sharing. Changing data structures after they were written to support read-only
sharing was difficult, since the main logical technique is the use of fractional
permissions. Read-only locking was challenging to retrofit support for, even
though it may have improved read-read concurrency in GoTxn and DaisyNFS.

\paragraph{Modular proofs.}

\Cref{ch:crash-logatom} describes a style for specifying a library in Perennial.
Modularity was essential to enable the GoTxn proof. Better support for
modularity, perhaps formalizing some of the aspects of the specification style,
would have more cleanly separated each library's proofs. Where this is
particularly important is in making changes to the code that affect an
interface, in which case it can be difficult to tell from the code exactly what
properties the caller is assuming about the interface. The specification style
was developed in parallel with all the proofs, which means that proofs do not
all follow the best practices developed along the way.

\section{Future work}

Model disk as asynchronous. Support asynchronous commit in GoTxn.  Use GoJournal
directly in conjunction with non-transactional state. Try to take advantage of
sequential reasoning from within Perennial --- how nice can this be, if we put
effort into it and learn from Dafny? We never really tried.

Experiment with logical logging in write-ahead log.

Apply Perennial to non-volatile memory or other storage APIs, like newer zoned
SSDs, or an asynchronous callback-style APIs.

Apply these techniques to Rust or C code. This would be a first step towards
better systems integration especially (not necessarily better performance).
Another important step for kernel integration would be modeling the interface,
which seems like a challenging problem.

More explicit testing of interface boundaries would be interesting, between Coq
and Dafny for example, but also disk API.

Treat NFS specification as a first-class project. Test the specification
directly with an executable, highly non-deterministic implementation. Test
against servers. Observe more client behavior in conjunction with exploring
server behavior. (I didn't have a testbed for rapidly trying out different
server behavior, other than just implementing it in DaisyNFS or at least GoNFS.)

\tej{describe future work with some more-complete text}
