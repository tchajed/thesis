\section{Program refinement specification}%
\label{sec:gotxn:spec}

At a high level, GoTxn makes transactions atomic. This chapter formalizes this
intuitive definition in the form of \emph{program refinement}. Later in
\cref{ch:daisy-nfs} we build upon this specification to show how it enables
sequential reasoning. Program refinement is defined in terms of
\emph{refinement}, which relates code to a specification. Abstractly, refinement
from a code program to a specification says that the behaviors of the code are a
subset of the behaviors of the specification.

To define the specification, we need to be more precise about what a program is
and how it executes to talk about the server loop program. We
write $p : \gooselayer{X}$ to say $p$ is a Go program written using operations
from layer X.
Layer operations are always atomic transitions in a state machine. Layers will
be one of Sys, Txn, or Disk, where Sys is a
stand-in for an arbitrary system implemented on top of GoTxn. We write this
generically to emphasize that the GoTxn specification does not fix how the
caller uses transactions; in practice it will be instantiated with the NFS state
machine for DaisyNFS.
The Txn layer consists of the GoTxn API, with reads and writes over a logical
disk and the ability to wrap these into an atomic transaction. The
Disk transition system is formalized in Coq as part of the GoTxn proof,
and assumes reads and writes of 4KB blocks are atomic. All layers
include concurrent threads that interleave layer
operations, basic heap operations on pointers, slices, and maps, and computation
on primitives like integers and structs.

The correctness for GoTxn relates a \emph{spec program} $p : \gooselayer{Txn}$
that uses transactions to its implementation. These specification programs can
invoke transactions, which we write $\atomically{\cc{f}}$ to represent a
transaction running \cc{f}, which in turn might have calls to Read and Write
from the GoTxn API. A specification program $p$ has an associated implementation
program $\mathrm{link}(\sdfy, \txncode) : \gooselayer{Disk}$, where we ``link''
with the GoTxn code. Linking has two effects: first it expands
$\atomically{\cc{f}}$ to a
sequence like \cc{tx := Begin(); f(tx); tx.Commit()} (with some additional code
handling aborts), and second it replaces calls to the Txn abstract Read and
Write operations with the GoTxn implementations at the Disk abstraction layer.

Refinement relates two programs in terms of their visible behavior, which is
used in the specification
to connect a program written at the transaction layer to its
implementation at the disk layer. This notion of refinement also incorporates
crashes into the outcomes of executing the program and gives it a corresponding specification.
For the purposes of this work, the visible
behavior is always network I/O, corresponding to receiving requests for the
system or responding to them (for example, processing NFS requests).

\begin{definition}[Refinement]
  An implementation program $p_{c}$ refines a specification program $p_{s}$,
written $p_{c} \refines p_{s}$, if whenever there are initial states
$\sigma_{s}$ and $\sigma_{c}$ satisfying $\mathrm{init}(\sigma_{s}, \sigma_{c})$
and $p_{c}$ can execute from $\sigma_{c}$ and produce a trace of network I/O
$\textit{tr}$, then $p_{s}$ can execute from $\sigma_{s}$ and produce the same trace
$\textit{tr}$.  Execution might involve crashing and restarting a program (potentially
multiple times), wiping out any in-memory state after each crash.
  \label{def:refinement}
\end{definition}

The intuition behind the notation $p_{c} \refines p_{s}$ is that the set of
behaviors of $p_{c}$ (the set of traces of network I/O $\textit{tr}$) is a subset of the
behaviors of $p_{s}$. Whenever we state $p_{c} \refines p_{s}$ we leave implicit
a definition of initial states $\mathrm{init}(\sigma_{s}, \sigma_{c})$, which
will generally say both states are all zeros and of the same size. This notion
of refinement is standard, except that we allow crashing in the execution of the
implementation, and this must correspond to a crash in the specification
program.

The specification we give to GoTxn uses \emph{program refinement},
which formalizes serializability (sometimes known as atomicity and isolation)
for transactions running on top of GoTxn.
To set up this specification, consider a program $p : \gooselayer{Txn}$ that
uses transactions.
To run $p$, it is combined with the transaction-system implementation, producing
a program $\mathrm{link}(p, \txncode) : \gooselayer{Disk}$ that can be run on
top of a disk.
Transactions in the linked program continue to have the expected atomic
behavior, so long as transaction code in $p$ follows certain restrictions, such
as not accessing shared state outside the journal system.  We write
$\mathrm{safe}(p)$ to mean $p$ is ``safe'' in the sense that it follows these restrictions.

% At a high level of abstraction, the main difficulty is to give a specification
% for the transaction system, which we do in several steps:
%
% \begin{enumerate}
%   \item First, we define an arbitrary Go program running on top of
%         the transaction system. For reasons we will explain shortly we will use
%         $p : \gooselayer{Txn}$ for such a program. To run such a program it
%         first needs to be linked with the transaction system implementation,
%         producing a program denoted $\mathrm{link}(p, \txncode)$.
%   \item The second idea is to say what the semantics of a program
%         $p : \gooselayer{Txn}$ is. Transactions are atomic in this semantics in
%         that the whole transaction transitions at once, without interleaving
%         other threads. The program can issue reads and writes within a
%         transaction, and they follow a simple state machine.
%   \item The final idea is to define ``safe'' programs $\mathrm{safe}(p)$, those
%         that follow the restrictions of the transaction system. The
%         specification only applies to safe programs.
% \end{enumerate}

The correctness of the transaction system is expressed by the following theorem:
%
\begin{theorem}[Program refinement]
  The transaction system's implementation $\txncode$ is a \emph{program refinement}, meaning for
  all $p : \gooselayer{Txn}$, if $\mathrm{safe}(p)$, then
  $\mathrm{link}(p, \txncode) \refines p$. The definition of
  $init(\sigma_{s}, \sigma_{c})$ in this refinement relates an all-zero physical
  disk to an all-zero transactional disk of the same size.
  \label{thm:gotxn-program-refinement}
\end{theorem}
%
What the theorem says is that if a program is safe, the program linked with the
transaction system always behaves as if its transactions were atomically
accessing a transactional disk logically maintained by the transaction system.
The theorem is stated in Coq and has a fully mechanized proof in Perennial.

\paragraph{Safe transactions}
The definition of $\mathrm{safe}(p)$ formalized in Coq requires that any code within a
transaction not access any shared memory outside of the transaction layer; other
than that, transactions can use GoTxn's \cc{Read} and \cc{Write} operations to
interact with the logical disk, and do any computation in between. For example
it is safe for transaction to issue data-dependent operations, where the
addresses in a transaction depend on earlier reads. The restriction to not use
other shared state is a natural one for the system's correctness; for example,
reads and writes to global variables would clearly be non-atomic since the
transaction system does not have any concurrency control or protection over such
variables.

Safety also requires that transactions follow the preconditions of
the \cc{Read} and \cc{Write} operations, which require a discipline of accessing
each object with a fixed size. Finally, safe programs can only \cc{Abort} or
\cc{Commit} a given transaction once. The notion of safe program will be
important when linking this proof with the Dafny proofs, since the transaction
system's proof only applies to a safe caller.
