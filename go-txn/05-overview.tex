\section{Verification overview}%
\label{sec:gotxn:overview}

% \begin{figure}
% %\includegraphics[width=\columnwidth]{fig/overview}
% \includegraphics{drawn-diagrams/jrnl-overview.png}
% \caption{Overview of Perennial, \txn, \simplenfs, and \gnfs.}
% \label{fig:overview}
% \end{figure}

\begin{figure}
\input{go-txn/fig/system}
\caption{Overview of Perennial, \txn, \simplenfs, and \gnfs.}
\label{fig:overview}
\end{figure}

\Cref{fig:overview} gives an overview of how \txn and systems
building on it are verified using Perennial.
On the left of the figure is the executable code, which is written
in Go. On top of \txn, we have implemented two NFS servers to evaluate \txn
along different dimensions. \gnfs is a functional NFS server that is sufficient
to run real applications, which we use to assess \txn's scalability and
performance. Meanwhile, \simplenfs is a verified, core subset of \gnfs's
functionality, which evaluates the usability of \txn's specs for building
verified systems on top of it.
% \gnfs supports most of RFC 1813~\cite{RFC:1813}, with
% the exception of symbolic links and permissions.  \gnfs supports the
% \cc{unstable} argument to the write RPC, allowing for writes that are
% not immediately flushed to disk, as well as the commit RPC that flushes
% these writes.  To allow this, \txn supports transactions that commit
% but are not immediately flushed to disk.  To formally validate the
% specifications of \txn, we verified \simplenfs, a core subset of \gnfs.

On the right side of the figure is the verification stack. The verification
builds on the Perennial 2.0 framework, which is itself implemented in the Iris
framework in the Coq proof assistant. To reason about executable code, a tool
called Goose translates a Go implementation into a model that we can prove
specifications about in Perennial. Perennial provides a model of execution for
Go code that incorporates crash-safety and concurrency, which
includes a model of the disk (with atomic, synchronous reads and writes of 4KB
sectors) as well as a model of crashes and recovery (crashes at arbitrary points
during execution, and jumping to specific boot code for recovery after a crash).

\txn's top-level specification describes its API in terms of an extension of
concurrent separation logic, with pre-, post-, and crash conditions. These
specifications capture the behavior of individual Go functions: if the function
is run in a state satisfying its precondition, then the final state will satisfy
the postcondition, and if the system crashes the state will satisfy the crash
condition. The specification for the journaling API is described in detail in \cref{s:design}. We
demonstrate the usefulness of this specification by proving correctness of the \simplenfs
server using logically atomic crash specifications (\cref{s:proof:logatom}). %, a style of specification
%encoded in Hoare triples.
The top-level theorem for \simplenfs states that its RPCs
atomically follow transitions of a state machine formalizing the NFSv3 protocol (based on RFC
1813~\cite{RFC:1813}).

As described in FSCQ and Argosy~\cite{chen:fscq,chajed:argosy}, crash conditions
can be used to reason about recovery procedures, even crashes during recovery. A
recovery procedure can safely be re-run after a crash if its specification is
\emph{idempotent}: its crash condition should imply its precondition. As an
end-to-end check of the crash specs in \simplenfs and \txn, showing they support
recovery correctly, we prove an idempotent specification for a toy example
client on top of \simplenfs, establishing that it can successfully execute even if
\simplenfs crashes and recovers an arbitrary number of times.

The proof of \txn's specification depends on a number of assumptions. We assume
that the disk writes 4KB blocks atomically, even on crash, and assume that the
code executes according to the Perennial model generated by Goose. The
specification relies on the caller to provide concurrency control; the proof of
\simplenfs checks that locking is performed correctly, but \gnfs is unverified
and we trust that its concurrency control is correct in order to make operations
atomic (though this does not say they correctly implement the NFS
specification).

% \begin{figure}[ht]
%   \input{go-txn/code/nfswritespec}
%   \vspace{-\baselineskip}
%   \caption{Specification for an NFS \textsc{write} which writes \cc{d} to
% file handle \cc{f} at offset \cc{off}. A wrapper around the spec checks that
% \cc{f} is a valid handle, passes the current file contents \cc{d0}, and allows
% the spec to return an error (e.g., if out of disk space). }
%   \label{fig:nfswritespec}
% \end{figure}
%
% \joe{We should probably trim this down now, since we don't much care about SimpleNFS's TCB anymore. Maybe rephrase it in terms of GoJournal's tcb?}
% The end-to-end proof for an application using \txn, such as \simplenfs, depends on a number of assumptions.
% The proof itself relies on the Coq proof assistant being correct, and
% on the top-level specification of \simplenfs correctly capturing its
% intended behavior.  The proof also relies on Goose to faithfully model
% the Go code of \simplenfs and \txn in Coq, and on the Go compiler and
% runtime to correctly execute the code.  The proof also assumes that the
% disk model is accurate (atomic and synchronous sector writes).  Finally,
% the proof does not cover the code that parses XDR-encoded RPC requests.
% We use a separate tool to generate this Go code from an XDR description
% of the protocols~\cite{RFC:1813, RFC:1057, RFC:4506}.
