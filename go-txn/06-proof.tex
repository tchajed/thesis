\section{Verifying GoTxn}
\label{sec:txn:proof}

This section outlines the proof of GoTxn's correctness, as described in
\cref{sec:txn:spec}. The implementation consists of multiple layers stacked
together, as described in \cref{sec:txn:impl}. The proof follows the same
structure, and the most interesting aspect is the specification for each layer.

Recall that program refinement is a statement about an arbitrary program that
uses transactions. It would be infeasible to directly reason the execution of an
arbitrary use of GoTxn, including handling concurrently issued transactions and
crashes at any time. Instead, the first step is to give a specification to the
individual methods of the GoTxn API, such as \cc{Read}, \cc{Write}, and
\cc{Commit}. Next, the proof considers an arbitrary transaction, but this part
of the proof can now invoke the specifications for each method.

In order to give a specification at the method level, we first
develop the right representation of the intermediate state of a transaction.
This representation needs to capture buffered writes (which will eventually be
durable at commit time) and the old values in the logical disk (which it will
revert to if the system crashes or the transaction aborts). It also needs to
handle concurrent transactions --- the tricky thing here is that the logical
disk can change in the middle of a transaction due to a concurrently committed
transaction, so for example the model of aborts cannot be as simple as reverting
to the disk at the start of the transaction.

A new lifting-based specification for journaling solves these problems. We
introduce a purely logical operation called \emph{lifting} that moves ownership
of a subset of the logical, durable disk into each concurrently executing
transaction. The transaction then operates freely on that part of the disk. This
works because the proof can only lift disjoint parts of the disk, which is
physically guaranteed by using a per-address lock in the \scc{txn} layer.
Eventually the transaction finishes reading and writing, and when it commits any
buffered changes can be merged into the global disk. Aborts are similarly
modeled, returning ownership and merging back the old values of just the local
disk.

\input{go-txn/lifting-spec.tex}
\input{go-txn/refinement-proof.tex}

\subsection[Write-ahead logging (WAL)]{Write-ahead logging (\scc{wal})}

The write-ahead log layer is responsible for updating multiple disk
blocks (a multiwrite) atomically.
Each multiwrite is a list
of updates, where an update consists of a disk block number and the new data to write in that block.
%The write-ahead log makes transactions atomic by first writing the
% updates to an on-disk log, and then installing them to their respective
% disk blocks.
A background logger thread moves multiwrites from an in-memory buffer to an
on-disk log. To make this atomic, the logger first writes
the contents of a multiwrite in a log entry, and then updates a designated header block to indicate
the entry is complete. If a crash
happens before the header is updated, none of the multiwrite's updates
are applied; if a crash happens after the header update, the multiwrite
will be applied during recovery.
Meanwhile, an installer thread applies entries in the log to the disk, clearing
space for new multiwrites.
If a crash happens before the updates in an entry are fully installed,
recovery installs the updates again from the on-disk log.

The write-ahead log implements two optimizations related to combining
multiwrites. Two or more multiwrites can be \emph{group committed} by logging
them together, which still guarantees their atomicity. If multiwrites being
committed together update the same block, the first update can be
\emph{absorbed} and replaced with the second. These optimizations trigger both
for multiwrites that are committed without waiting for durability and also for
concurrent, synchronous multiwrites.

% When a transaction is written in the log,
% updates to the on-disk log is made atomic by first writing the updates
% to the log, and then updating a designated header block.
%
% If a crash
% happens before the header is updated, none of the transaction's updates
% are applied; if a crash happens after the header update, the transaction
% will be applied during recovery.

% Write-ahead logging is a standard approach for atomic disk writes, but it
% is complicated by performance and crash safety requirements.  For example,
% writing transactions to disk requires waiting for a disk write, which
% can be slow.  To improve performance, many storage applications do not
% flush transactions to disk immediately (e.g., unstable \scc{write} RPCs
% in NFSv3), but do require that the on-disk state be consistent (i.e.,
% no partially applied or out-of-order transactions) after a crash.
% Furthermore, because disk writes are slow, many operations need to
% happen in parallel, without holding locks while waiting for disk reads
% and writes: committing new transactions in memory; logging transactions
% from memory to disk; waiting for transactions to be made durable; and
% installing transactions.  Concurrency ensures that in-memory operations
% need not wait for any in-flight disk reads or writes, and that many
% disk reads and writes can happen at the same time.  Finally, to reduce
% the number of disk writes, multiple in-memory transactions are logged
% to disk together (``group commit''), and if they update the same disk
% block multiple times, only the most recent update of that disk block is
% written to the log (``absorption'').

% Formally verifying a high-performance write-ahead log is challenging
% because of the lock-free concurrency, and because the log must maintain
% crash-safety at all times.


\paragraph{Internal abstract state: logical log.}
To prove the write-ahead log layer correct, the proof represents the
state of the write-ahead log as a logical list of multiwrites, as
shown in \cref{fig:log}.  Multiwrites before \cc{memStart} have
already been installed, and their log entries do not physically exist in memory or on disk.
Multiwrites from \cc{memStart} to \cc{diskEnd} are already logged on
disk.  Multiwrites from \cc{diskEnd} to \cc{nextDiskEnd} are currently being logged
from memory to disk.  Finally, multiwrites between \cc{nextDiskEnd}
and \cc{memEnd} are purely in-memory, and are eligible for absorption.

\begin{figure}[ht]
    \input{go-txn/fig/log}
    \vspace{0.5 \baselineskip}
    \caption{The logical write-ahead log.  Vertical arrows indicate
        designated positions in the logical log.  Labels below the arrows
        indicate what thread or function is responsible for advancing
        that logical position to the right.}
    \label{fig:log}
\end{figure}

This representation allows the WAL's proof to precisely specify how concurrent
operations modify this abstract state, and how the state changes on crash.
For example, although the installer thread performs many disk writes to
install multiwrites, its only effect on the abstract state is that it
advances \cc{memStart}.  Similarly, the logger thread's only change to
the abstract state is to advance \cc{diskEnd}.  Calling \cc{Flush()}
advances \cc{nextDiskEnd}, freezing the data to be logged, then waits
for the logger to advance \cc{diskEnd} up to that point.  Committing a
new multiwrite simply appends it at \cc{memEnd}.  Finally, on crash,
an arbitrary suffix of the log from \cc{diskEnd} onwards is discarded.


\paragraph{External abstract state: durable lower bound.}
Although the details of the logical log are important for proving the
\scc{wal} layer, the caller (i.e., the \scc{obj} layer) does not need
to know about installation, group commit, etc. To abstract away these
details, the \scc{wal} provides a simplified state as its interface,
as shown in \cref{fig:wal-spec}.  The simplified state consists of
the same list of multiwrites, together with \cc{durable_lb}, which is
a lower bound on what set of multiwrites will be preserved on crash.
Using a lower bound instead of precisely exporting \cc{diskEnd} means
that this abstract view does not need to change if the logger thread
adds more multiwrites to disk in the background, and thus hides
this concurrency.

\begin{figure}[ht]
  \begin{minted}{coq}
Record update := { addr: u64; data: Block; }.
Record State :=
  { multiwrites: list (list update);
    (* at least durable_lb elements are durable *)
    durable_lb: nat; }.

Definition mem_append (ws: list update) :
    transition State unit :=
  modify (set multiwrites (fun l => l ++ [ws]));
  ret tt.

(* non-deterministically pick how many
   multiwrites survive the crash. *)
Definition crash : transition State unit :=
  durable <- suchThat (fun s i => durable_lb s â‰¤ i);
  modify (set multiwrites (fun l => l[:durable]));
  modify (set durable_lb (fun _ => durable));
  ret tt.
  \end{minted}
\caption{Parts of the specification for the \scc{wal} interface.}
\label{fig:wal-spec}
\end{figure}


\paragraph{Lock-free logging and installation.}
For performance, GoTxn has dedicated threads that perform logging and
installation.  However, these threads do not hold any locks while reading
or writing to disk.  To allow these threads to run concurrently, the write-ahead
log layer
uses two separate header blocks, as shown in \cref{fig:physlog}.
One header block (owned by the installer thread) stores the start of
the on-disk log, and another header block (owned by the logger thread)
stores the end of the on-disk log.  This lets the installer and logger
concurrently advance their pointers (\cc{memStart} and \cc{diskEnd}
respectively) without locks.

\begin{figure}
    \centering
    \input{go-txn/fig/physlog}
    \caption{The physical write-ahead log.}
    \label{fig:physlog}
\end{figure}

Although the logger and installer threads can perform lock-free disk
writes, they must still coordinate with one another.  For example,
the installer cannot run ahead of the logger thread, and the logger
thread must coordinate with threads that are appending new multiwrites
in memory. GoTxn's proof uses the notion of \emph{monotonic counters} to reason
about the safety of the logger and installer's lock-free operations.

The logger thread needs to check that \cc{memStart} is far enough along that the
log will have space for the new multiwrite. The proof gets a \emph{lower bound}
on the \cc{memStart} variable while holding a lock, which remains true even
after releasing the lock. Even though \cc{memStart} might grow after the initial
check, the log will only have more space and thus the multiwrite will still fit.

The installer has a similar lock-free region that also reasons using a lower
bound. The installer retrieves the updates from the current \cc{memStart} to
\cc{diskEnd} in order to start installing them to disk. When the installer
eventually trims the log, it needs to be sure not to advance beyond the current
logger position, which the proof demonstrates using a lower bound on
\cc{diskEnd} from when the logger initially started.

\subsection{Logically atomic crash specifications}
\label{sec:txn:logatom}

Throughout the GoTxn stack we specify internal layers using a transition-system
specification, such as the examples illustrated in \cref{fig:wal-spec} for
the \scc{wal} layer. Perennial formalizes what it means for the code in a layer to
implement a transition system in terms of Perennial's crash triples in a style we call
\emph{logically atomic crash specifications}. \Cref{ch:crash-logatom} gives a
more complete description of this encoding. This section gives the high-level
intuition for how these specifications are used in the context of the GoTxn
layers.

As a motivating example, consider the moment when the logger thread commits a
new batch of multiwrites to the physical log in order to advance the durable
point \cc{diskEnd} in the logical log of the \scc{wal} layer. It does this by calling into the
\cc{Append} method of the \scc{circular} layer, which appends to the small
buffer of logged multiwrites. The code for \cc{Append} commits at some internal
step when it writes the header block and makes the data valid, and it is at this
instant that the logical log's \cc{diskEnd} should be incremented.
How can we verify \cc{Append} in the \scc{circular} layer separately from the \scc{wal} layer,
while still executing the right update in the logger proof?

Logically atomic specifications achieve this separation by having the precondition to \cc{Append}
take a logical \emph{callback}~\cite{jacobs:logatom}, which the proof promises to ``execute'' at the commit point.
This callback is a view-shift assertion of the form $P \vs Q$, a feature in Iris
which expresses an update to ghost state that takes the assertion $P$ as input
and produces $Q$ as output. The exact update is selected by the logger proof to
update the \cc{diskEnd} ghost state of the logical log, as shown in
\cref{fig:circ-callback}.
% The logger proof maintains a
% ghost variable $\gamma \mapsto \cc{diskEnd}$, much like other points-to predicates,
% but variable $\gamma$ exists only in the proof. It passes an update to this
% variable
% $\hoare{\gamma \mapsto \cc{diskEnd}}%
% {\SKIP}%
% {\gamma \mapsto (\cc{diskEnd} + \cc{len}(\cc{txns}))}$
% as the callback, as illustrated in \cref{fig:circ-callback}.
%(we use the
%shorthand $\gamma\ \cc{+=}\ \cc{len(txns)}$ for
%space reasons).
This
specification for \cc{Append} provides modularity in that the \cc{Append} proof
does not need to know about the logical log and its \cc{diskEnd}, and the logger
proof does not need to worry about why \cc{Append} is atomic.  A key
feature of Perennial's logically atomic crash specs lies in that they capture the
crash behavior in this callback style, so as to enable a complete
proof of crash safety across layers.

\begin{figure}
  \input{go-txn/fig/appendhocap}
  \caption{Illustration of how the proof of \cc{Append} executes a logical
callback $P \vs Q$, an assertion in Perennial which updates ghost state. The
logger passes a callback that adds \cc{len(txns)} to the \cc{diskEnd} ghost variable.}
% $\gamma\ \cc{+=}\ \cc{len(txns)}$.
% Note that the proof of
% \cc{Append} does not need to know the details of what \textcolor[rgb]{0.35,
% 0.35, 0.35}{cb} does.}
  \label{fig:circ-callback}
\end{figure}

\subsection{Concurrency within a block (\scc{obj})}
\label{s:proof:obj}

\txn's \scc{obj} layer allows the caller to issue reads and writes that
are smaller than a full block.  This finer granularity helps increase
concurrency: for example, the NFS file server packs multiple inodes into
a single disk block, and \scc{obj} allows threads to concurrently read
and write multiple inodes even if they share a disk block.

At commit time, \scc{obj}'s \cc{Commit} may need to perform an
``installation read'' and read a full block, update the range that was
modified by the caller as part of a journal operation, and write back the
full block using the \scc{wal} layer.  To ensure correctness of this
read-modify-write operation, \cc{Commit} uses a lock to serialize
all commit operations.  However, \cc{Read} operations are lock-free:
they can execute concurrently with one another and concurrently with
\cc{Commit}.

Lock-free reads pose a verification challenge because the disk
block can be modified during the read.  Consider the example shown
in \cref{fig:txn-concur}, where a single disk block stores many
inodes. Inode 1 initially contains the value A, while inode 4 contains B. Thread 1 is committing a write of B' to inode 4 in that block, while
thread 2 concurrently reads inode 1 from the same block.  To read
inode 1, thread 2 will read the entire block, and then copy out the part
of the block corresponding to inode 1.  The block seen by
thread 2 will differ depending on whether thread 1's write happens
before or after the read, but inode 1 will contain A in either case.

%\begin{figure}[ht]
%\centering
%\includegraphics{drawn-diagrams/sub-block-concurrency.png}
%\caption{An example of a concurrent \cc{Read} and \cc{Commit}
%  in the \scc{obj} layer.}
%\label{fig:txn-concur}
%\end{figure}

\begin{figure}[ht]
\centering
\input{go-txn/fig/sub-block-concurrency}
\caption{An example of a concurrent \cc{Read} of inode 1 and \cc{Commit}
  modifying inode 4
  in the \scc{obj} layer.}
\label{fig:txn-concur}
\end{figure}

Formally reasoning about the \cc{Read} operation requires the \scc{obj}
layer to connect the $a \mapsto_{\mathit{op}} o$ predicate about a disk object
(such as an inode) to the disk block containing that object at the
\scc{wal} layer.  However, due to the race condition described above,
the \cc{Read} implementation might observe many possible values of the
containing disk block.  As a result, it is important for the \scc{obj}
invariant to relate the $a \mapsto_{\mathit{op}} o$ predicate not just to
the latest value of the containing block, but to all recent contents
of that block.  Specifically, the invariant for $a \mapsto_{\mathit{op}} o$
requires that all recent writes to $a$'s block (since \cc{Read(a)}
started) must agree on the part of the block storing $o$.  As a result,
regardless of what block happened to be read,
the caller is guaranteed to see the correct object $o$.

\subsection[Lock-free reads in WAL]{Lock-free reads in \scc{wal}}

\Cref{fig:walread} shows the implementation of \cc{Read} in the
\scc{wal} layer.  This implementation is split into two parts. The first part checks
the in-memory state by consulting \cc{l.memLog} under a lock, checking for any
updates to the address being read between \cc{memStart} and \cc{memEnd}. If
no in-memory updates match the address being read, the second part of \cc{Read} falls back
to reading from the installed area on disk.  No lock is held across the whole
operation, so other threads
can run between the call to \cc{ReadMem()} and \cc{ReadInstalled()}.
In particular, a thread could run \cc{Commit()}
to the same block that another thread is reading, if the two threads
are accessing different parts of the same block, as shown in \cref{fig:txn-concur}.

\begin{figure}[ht]
\begin{minted}{go}
func (l *Wal) Read(a uint64) Block {
  b, ok := l.ReadMem(a)
  if ok { return b }
  return l.ReadInstalled(a)
}

func (l *Wal) ReadMem(a) (Block, bool) {
  l.Lock()
  b, ok := l.memLog.get(a)
  l.Unlock()
  return b, ok
}

func (l *Wal) ReadInstalled(a uint64) Block {
  return disk.Read(a)
}
\end{minted}
\caption{The implementation of \cc{Read} in the \scc{wal} layer.}
\label{fig:walread}
\end{figure}

There is a challenge in specifying the behavior of \cc{Read} because its commit
point is not obvious. \tej{add a figure for this explanation} Consider a case
where address $a$ is not in the in-memory log, so that the \cc{Read} operation
falls back to \cc{ReadInstalled(a)}. If there is a concurrent write to address
$a$, then there are two possibilities for the linearization point of the
\cc{Read} call: it can either appear to occur before the concurrent write, if
\cc{ReadInstalled(a)} returns the old value, or its linearization point might be
after the write if the concurrent write is installed before
\cc{ReadInstalled(a)} runs. Unfortunately the decision to linearize before
\cc{ReadInstalled(a)} or at the point it runs \emph{depends on the future
  behavior} of the system (the linearization point is before if there is no
concurrent write that gets installed, and not otherwise).

Instead of proving that \cc{Read} is atomic, we instead give atomic specifications to
\cc{ReadMem()} and \cc{ReadInstalled()} individually. The write-ahead log's
abstract state includes a lower bound on its installed point in order to
describe \cc{ReadInstalled()} in isolation. The specification for \cc{ReadMem}
on missing in the cache
advances the installed lower bound enough to guarantee that there are no writes
to that address after the new installed point. The specification for
\cc{ReadInstalled()} can return any value the address has after the
installed lower-bound. To reason about the combination of these operations, the
\scc{obj} layer maintains a strong invariant about all the possible blocks that
\cc{Read} could return from the installed point onward, and this is enough to
reason about a block returned from either the cache or the installed data.

Formally, we believe that it is possible to prove that the \scc{wal} \cc{Read()}
operation is linearizable, but because of the future-dependence this
will require using \emph{prophecy variables}.  Perennial
does not support them, which forced us to adopt the non-atomic
specification described above.  Recent results on prophecy variables
in Iris~\cite{jung:prophecy} could be used to avoid specifying
\cc{ReadInstalled()} separately.
