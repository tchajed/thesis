\section{GoTxn's specification}%
\label{sec:gotxn:spec}

\tej{This section should be reframed a bit to set context. The new framing is
that this section is all about describing GoTxn's top-level and intermediate
specifications, as it is a big system and is verified in several steps. The
main areas will be describing program refinement, lifting for GoJournal, and how
we verify 2PL; then we'll give the write-ahead log abstract state (as in job
talk) and describe how the object layer handles concurrency within a block
(invariant) and the lock during commit.}

\resume

At a high level, GoTxn makes transactions atomic. We frame its specification in
two ways. The first, \emph{program refinement}, formalizes the idea of ``atomic
transactions''. The second, \emph{simulation transfer}, uses
program refinement to show that a sequential proof of a system's transactions
implies the concurrent system is correct running on top of GoTxn.

Before we can get to defining program refinement, we first set up
\emph{refinement}, which is the relationship between the code and spec.
Abstractly, refinement from a code program to
a specification program says that the behaviors of the code are a subset of the
behaviors of the specification.

To define the specification, we need to be more precise about what a program is
and how it executes to talk about the server loop program. We
write $p : \gooselayer{X}$ to say $p$ is a Go program written using operations
from layer X, where X is one of Sys, Txn, or Disk.
Layer operations are always atomic transitions in a state machine. Sys is a
stand-in for an arbitrary system implemented on top of GoTxn. We write this
generically to emphasize that the GoTxn specification does not fix how the
caller uses transactions; in practice it will be instantiated with the NFS state
machine for DaisyNFS.
The Txn layer is specified both in Coq where it is part of the transaction
system's correctness theorem and in Dafny where it appears as an assumption. The
Disk transition system is formalized in Coq as part of the GoJournal proof,
and assumes reads and writes of 4KB blocks are atomic. Each layer
includes concurrent threads that interleave layer
operations, basic heap operations on pointers, slices, and maps, and computation
on primitives like integers and structs.

There are three programs involved in defining and proving the overall
correctness of some system using GoTxn, each at a different level of abstraction.
The abstract specification is some system dispatch loop $\ssys : \gooselayer{Sys}$ which
atomically processes each operation in the Sys interface. The
next level is $\sdfy : \gooselayer{Txn}$, where each handler is the atomic body of the
corresponding Dafny method, operating on top of the transaction system. Finally,
the executable code is written
$\mathrm{link}(\sdfy, \txncode) : \gooselayer{Disk}$, indicating ``linking'' the
Txn-layer server $\sdfy$ with the transaction system by taking each call to a
Txn API and plugging in its implementation on top of a disk.
%\Cref{fig:refinement-execs} illustrates one execution of this dispatch loop for
%the DaisyNFS server, when clients issue a \cc{LOOKUP} and \cc{CREATE} in
%parallel; for correctness, the operations should be atomic and follow the NFS
%specification despite interleaving at the code level (the bottom execution).

In the Txn layer, we write $\atomically{\cc{f}}$ to represent a
transaction running \cc{f}. This is a macro that expands to a
sequence like \cc{tx := Begin(); f(tx); tx.Commit()} (some additional code
handling aborts is omitted in this snippet).
% At the specification
% level, an atomically block represents a whole sequence of operations that
% executes all at once, without crashes or other threads interrupting.

Refinement relates two programs in terms of their visible behavior, which we
will use to connect the server loop at the disk layer to the transaction layer
and finally to the Sys layer. For the purposes of this work, the visible
behavior is always network I/O, corresponding to receiving requests for the
system or responding to them (for example, processing NFS requests). Regardless
of the level of abstraction, each model of the server defines a trace of network
I/O consisting of requests and responses, and this is the behavior refinement
talks about:

\begin{definition}[Refinement]
  An implementation program $p_{c}$ refines a specification program $p_{s}$,
written $p_{c} \refines p_{s}$, if whenever there are initial states
$\sigma_{s}$ and $\sigma_{c}$ satisfying $\mathrm{init}(\sigma_{s}, \sigma_{c})$
and $p_{c}$ can execute from $\sigma_{c}$ and produce a trace of network I/O
$\textit{tr}$, then $p_{s}$ can execute from $\sigma_{s}$ and produce the same trace
$\textit{tr}$.  Execution might involve crashing and restarting a program (potentially
multiple times), wiping out any in-memory state after each crash.
  \label{def:refinement}
\end{definition}

The intuition behind the notation $p_{c} \refines p_{s}$ is that the set of
behaviors of $p_{c}$ (the set of traces of network I/O $\textit{tr}$) is a subset of the
behaviors of $p_{s}$. Whenever we state $p_{c} \refines p_{s}$ we leave implicit
a definition of initial states $\mathrm{init}(\sigma_{s}, \sigma_{c})$, which
will generally say both states are all zeros and of the same size.

\subsection{Program refinement}

The first specification we give to GoTxn is using \emph{program refinement},
which formalizes serializability (sometimes known as atomicity and isolation) for transactions.
To set up this specification, consider a program $p : \gooselayer{Txn}$ that
uses transactions.
To run $p$, it is combined with the transaction-system implementation, producing
a program $\mathrm{link}(p, \txncode) : \gooselayer{Disk}$ that can be run on
top of a disk.
Transactions in the linked program continue to have the expected atomic
behavior, so long as transaction code in $p$ follows certain restrictions, such
as not accessing shared state outside the journal system.  We write
$\mathrm{safe}(p)$ to mean $p$ is ``safe'' in the sense that it follows these restrictions.

% At a high level of abstraction, the main difficulty is to give a specification
% for the transaction system, which we do in several steps:
%
% \begin{enumerate}
%   \item First, we define an arbitrary Go program running on top of
%         the transaction system. For reasons we will explain shortly we will use
%         $p : \gooselayer{Txn}$ for such a program. To run such a program it
%         first needs to be linked with the transaction system implementation,
%         producing a program denoted $\mathrm{link}(p, \txncode)$.
%   \item The second idea is to say what the semantics of a program
%         $p : \gooselayer{Txn}$ is. Transactions are atomic in this semantics in
%         that the whole transaction transitions at once, without interleaving
%         other threads. The program can issue reads and writes within a
%         transaction, and they follow a simple state machine.
%   \item The final idea is to define ``safe'' programs $\mathrm{safe}(p)$, those
%         that follow the restrictions of the transaction system. The
%         specification only applies to safe programs.
% \end{enumerate}

The correctness of the transaction system is summarized by the following theorem:

\begin{theorem}[Program refinement]
  The transaction system's implementation $\txncode$ is a \emph{program refinement}, meaning for
  all $p : \gooselayer{Txn}$, if $\mathrm{safe}(p)$, then
  $\mathrm{link}(p, \txncode) \refines p$. The definition of
  $init(\sigma_{s}, \sigma_{c})$ in this refinement relates an all-zero physical
  disk to an all-zero transactional disk of the same size.
  \label{thm:gotxn-program-refinement}
\end{theorem}

\Cref{thm:txn} is stated in Coq and has a fully mechanized proof in Perennial.
What it says is that if a program is safe, the program linked with the
transaction system always behaves as if its transactions were atomically
accessing a transactional disk logically maintained by the transaction system.
The definition of safety formalized in Coq requires that code within a
transaction not access any shared memory outside of the transaction layer; other
than that, transactions are permitted to issue reads, writes, and do other
computation. Safety also requires that transactions follow the preconditions of
the \cc{Read} and \cc{Write} operations, which require a discipline of accessing
each object with a fixed size. Finally, safe programs can only \cc{Abort} or
\cc{Commit} a given transaction once. The notion of safe program will be
important when linking this proof with the Dafny proofs, since the transaction
system's proof only applies to a safe caller.

\subsection{Simulation transfer}

\tej{decided to move this to DaisyNFS chapter, so that program refinement is the
conclusion of this chapter}

Program refinement captures how transactions execute. On top of this
specification, we prove a \emph{simulation transfer} theorem that instead shows
how transactions enable \emph{sequential reasoning} for a system on top. In
DaisyNFS we will see how this justifies carrying out those proofs using Dafny, a
sequential verification system.

The idea behind the simulation transfer specification is to express that a system
verified using sequential reasoning for each transaction is also correct when
run concurrently through GoTxn --- intuitively, this follows from the atomicity
provided by program refinement.
% , at which point the sequential reasoning
% applies, but we have a more precise and formal proof in Coq.
To make this precise, we define formally what we mean by
``sequential reasoning''. Suppose we have an
implementation of layer $S$ using operations from $T$. Note that all the proofs
about the transaction system are for an arbitrary system with operations in $S$. The implementation $i$
consists of a function $i(op) : \gooselayer{T}$ for each operation $op \in S$. The statement
$\seqrefinement \targ{T, S}(i)$ says that $i$ is a correct sequential
implementation of $S$ using $T$. To specify correctness under crashes, this
definition refers to $\operatorname{crash}(\sigma, \sigma')$, which is a
layer-specific crash transition that models, for example, clearing the
contents of memory.

\begin{definition}
  The implementation $i : S \to \gooselayer{T}$ is a \emph{sequential
    refinement}, written
  $\seqrefinement \targ{T, S}(i)$, if there exists an abstraction relation
  $R : \Sigma_{S} \to \Sigma_{T} \to \textdom{bool}$ such that: \newline
(1) for every operation
  $op \in S$, the following sequential Hoare triple holds:
  \[
    \hoare{R(\sigma)}{i(op)}{\exists \sigma'.\, R(\sigma') \land \sigma \overset{op}{\leadsto} \sigma'},
  \]
(2) $\mathrm{init}(\sigma_{S}, \sigma_{T})$ implies
$R(\sigma_{S}, \sigma_{T})$, and \\
(3) if $R(\sigma_{T}, \sigma_{S})$ holds and $\operatorname{crash}(\sigma_{T}$, $\sigma_{T}')$,
then there exists a $\sigma_{S}'$ such that $R(\sigma_{T}', \sigma_{S}')$ and
$\operatorname{crash}(\sigma_{S}, \sigma_{S}')$.%
  \label{def:seqrefinement}
\end{definition}
%
Conditions (1) and (2) in this definition are standard for sequential
verification of refinement, while condition (3) is a standard condition for sequential crash-safety~\citep{chajed:argosy}. Though condition (3) requires the
abstraction relation to be preserved by crashes, the proof engineer does \emph{not} have to reason about crashes in the middle of operations.
% is a standard condition for sequential crash-safety~\cite{chajed:argosy}
% for sequential crash safety~\cite{chajed:argosy}.
The
diagram in \cref{fig:refinement} depicts the main
refinement condition (1) diagrammatically. \tej{after moving this will be a
  reasonable forward reference}
% For example, it is fairly easy to use them to show
% that for any sequential program $p : \gooselayer{S}$, the traces of the code
% $\mathrm{link}(p, i)$ are a subset of the traces of the spec $p$ (we will not
% use exactly this theorem since we are interested in concurrent code using
% transactions).
% \tej{I mentioned this but maybe we don't want/need to say it?}. Such reasoning would be familiar in previous sequential verified
% systems like FSCQ~\cite{chen:fscq}, IronFleet~\cite{hawblitzel:ironfleet}, and
% VeriBetrKV~\cite{hance:veribetrkv}.

The correctness theorem for GoTxn takes a proof of \emph{sequential} refinement
conditions for a system implemented using transactions and derives a \emph{concurrent and crash-safe} refinement.
A transaction must satisfy some conditions to ensure atomicity. We write
$\mathrm{safe}(p)$ to say that $p$ is a valid transaction. The main
restriction is that $p$ cannot access global state such as the heap, since
the transaction system does not make such accesses atomic.
The implementation $i$
in this theorem gives only the body of each transaction; the theorem is about
$\atomiccomp i$ where $(\atomiccomp i)(op) = \atomically{i(op)}$ uses
the macro from the Txn layer to specify that the
operation is wrapped in a transaction.
%\begin{verbatim}
%type txnBody =
%  func(tx *Txn) (v interface{}, ok bool)
%func runTxn(f txnBody) (v interface{}, ok bool) {
%  tx := Begin()
%  v, ok := f(tx)
%  if ok {
%    tx.Commit()
%  } else {
%    tx.Abort()
%  }
%  return v, ok
%}
%\end{verbatim}
\begin{theorem}[Simulation transfer]
  Let $\textdom{Sys}$ be a layer implemented using transactions with
$i : \textdom{Sys} \to \gooselayer{Txn}$, such that
$\seqrefinement\targ{\gooselayer{Txn}, \textdom{Sys}}(i)$ and
$\forall op.\, \mathrm{safe}(i(op))$ hold. Then
\[
  \forall p : \gooselayer{Sys}, \linked{\mathrm{link}(p, \atomiccomp i)} \refines p.
\]
\label{thm:gotxn-transfer}
\end{theorem}
%Notice that this theorem assumes simply an implementation of some interface $S$
% using transactions and a proof of its correctness in terms of standard
% \emph{sequential} reasoning, while the conclusion says that the combination of
% the implementation with GoTxn results in a correct \emph{concurrent} refinement.
%In \cref{sec:txn-proof} we discuss how this theorem
%is proven using Perennial and Coq.
